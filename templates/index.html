<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Acquacotta</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/dark.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --success: #4ecca3;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        .timer-row {
            display: flex;
            gap: 1.5rem;
            align-items: stretch;
        }
        .timer-row .weekly-overview {
            flex: 1;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        .timer-row .weekly-overview .week-chart-container {
            flex: 1;
            min-height: 200px;
        }
        .timer-row .timer-container {
            flex: 0 0 320px;
        }
        .timer-details {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-primary);
            border-radius: 8px;
        }
        .timer-details input,
        .timer-details select,
        .timer-details textarea {
            font-size: 0.875rem;
        }
        nav {
            display: flex; gap: 0.5rem;
            background: var(--bg-secondary);
            padding: 0.5rem; border-radius: 8px; margin-bottom: 0.5rem;
        }
        nav button {
            flex: 1; padding: 0.75rem; border: none; border-radius: 8px;
            background: transparent; color: var(--text-secondary);
            cursor: pointer; font-size: 1rem;
        }
        nav button:hover { background: var(--bg-tertiary); color: var(--text-primary); }
        nav button.active { background: var(--accent); color: white; }
        .view { display: none; }
        .view.active { display: block; }
        .card {
            background: var(--bg-secondary);
            border-radius: 8px; padding: 1rem; margin-bottom: 0.75rem;
        }
        button.primary {
            background: var(--accent); color: white; border: none;
            padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer;
            font-size: 1rem;
        }
        button.primary:hover { background: var(--accent-hover); }
        button.secondary {
            background: var(--bg-tertiary); color: var(--text-primary);
            border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer;
        }
        input, select, textarea {
            background: var(--bg-primary); border: 1px solid var(--bg-tertiary);
            border-radius: 8px; color: var(--text-primary);
            padding: 0.75rem; font-size: 1rem; width: 100%;
        }
        input:focus, select:focus { outline: none; border-color: var(--accent); }
        label { display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.875rem; }
        .form-group { margin-bottom: 1rem; }
        h2 { margin-bottom: 1rem; }
        h3 { font-size: 1rem; color: var(--text-secondary); margin-bottom: 0.5rem; }

        /* Timer */
        .timer-container { text-align: center; padding: 1rem; }
        .timer-display { position: relative; width: 280px; height: 280px; margin: 0 auto 1rem; cursor: grab; touch-action: none; }
        .timer-ring {
            transform: rotate(-90deg);
            touch-action: none;
            cursor: grab;
            user-select: none;
        }
        .timer-ring-bg { fill: none; stroke: var(--bg-tertiary); stroke-width: 8; }
        .timer-ring-progress {
            fill: none; stroke: var(--accent); stroke-width: 8;
            stroke-linecap: butt;
        }
        .timer-ring-progress.break { stroke: var(--success); }
        #timer-end-cap.break { fill: var(--success); }
        .timer-ticks { pointer-events: none; }
        .timer-text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); text-align: center;
            pointer-events: none;
        }
        .timer-time { font-size: 3.5rem; font-weight: 700; font-variant-numeric: tabular-nums; }
        .timer-status { color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; }
        .timer-controls { display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap; }
        .timer-controls button { width: 70px; height: 40px; padding: 0; text-align: center; font-size: 0.875rem; }
        .duration-presets { display: flex; gap: 0.5rem; justify-content: center; margin-bottom: 0.5rem; }
        .duration-presets button {
            min-width: 60px; height: 44px; padding: 0.5rem 0.75rem; border: 2px solid var(--bg-tertiary); border-radius: 8px;
            background: transparent; color: var(--text-secondary); cursor: pointer; font-size: 0.875rem; font-weight: 500;
            transition: all 0.2s;
        }
        .duration-presets button:hover { border-color: var(--accent); color: var(--text-primary); }
        .duration-presets button.active { border-color: var(--accent); background: var(--accent); color: white; }

        /* Break Info */
        .break-info { text-align: center; color: var(--text-secondary); font-size: 0.75rem; margin-top: 0.5rem; margin-bottom: 0.75rem; }
        .break-progress-bar {
            display: flex; gap: 6px; justify-content: center; align-items: center; margin-bottom: 0.25rem;
        }
        .break-progress-bar .segment {
            width: 24px; height: 8px; border-radius: 4px; background: var(--bg-tertiary);
            transition: background 0.2s; cursor: pointer;
        }
        .break-progress-bar .segment:hover { background: var(--text-secondary); }
        .break-progress-bar .segment.filled { background: var(--accent); }
        .break-progress-bar .segment.current { background: var(--accent); }

        /* Break Presets */
        .break-presets { display: flex; gap: 0.5rem; justify-content: center; margin-bottom: 0.25rem; }
        .break-presets button {
            min-width: 60px; height: 44px; padding: 0.5rem 0.75rem; border: 2px solid var(--bg-tertiary); border-radius: 8px;
            background: transparent; color: var(--text-secondary); cursor: pointer; font-size: 0.875rem; font-weight: 500;
            transition: all 0.2s;
        }
        .break-presets button:hover { border-color: var(--success); color: var(--text-primary); }
        .break-presets button.active { border-color: var(--success); background: var(--success); color: white; }

        /* Modal */
        .modal-overlay {
            display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7); align-items: center; justify-content: center; z-index: 100;
        }
        .modal-overlay.active { display: flex; }
        .modal { background: var(--bg-secondary); border-radius: 8px; padding: 1.5rem; width: 100%; max-width: 400px; margin: 1rem; }
        .modal h2 { margin-bottom: 1.5rem; }
        .modal-actions { display: flex; gap: 0.75rem; justify-content: flex-end; margin-top: 1.5rem; }

        /* History */
        .pomodoro-item {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 1rem; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 0.5rem;
            transition: box-shadow 0.3s ease, background 0.3s ease;
            cursor: pointer;
        }
        .pomodoro-item:hover {
            background: var(--bg-tertiary);
        }
        .pomodoro-item.highlighted {
            box-shadow: 0 0 0 2px var(--accent), 0 0 20px rgba(233, 69, 96, 0.3);
            background: var(--bg-tertiary);
        }
        .pomodoro-name { font-weight: 500; }
        .pomodoro-type {
            display: inline-block; font-size: 0.75rem; padding: 0.25rem 0.5rem;
            border-radius: 4px; margin-left: 0.5rem;
        }
        .pomodoro-meta { font-size: 0.875rem; color: var(--text-secondary); margin-top: 0.25rem; }
        .pomodoro-actions { display: flex; align-items: center; gap: 0.25rem; }
        .pomodoro-actions button {
            background: none; border: none; color: var(--text-secondary);
            cursor: pointer; padding: 0.5rem; font-size: 1rem;
        }
        .pomodoro-actions button:hover { color: var(--text-primary); }
        .empty { text-align: center; padding: 3rem; color: var(--text-secondary); }

        /* Reports */
        .summary-cards { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem; }
        .summary-card { text-align: center; padding: 1.5rem 1rem; }
        .summary-value { display: block; font-size: 2rem; font-weight: 700; color: var(--accent); }
        .summary-label { font-size: 0.875rem; color: var(--text-secondary); }
        .period-nav { display: flex; align-items: center; justify-content: center; gap: 1rem; margin-bottom: 1rem; }
        .period-selector { display: flex; gap: 0.5rem; background: var(--bg-secondary); padding: 0.25rem; border-radius: 8px; margin-bottom: 1rem; }
        .period-selector button { flex: 1; padding: 0.5rem; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; border-radius: 6px; }
        .period-selector button.active { background: var(--bg-tertiary); color: var(--text-primary); }
        .chart-container { height: 250px; margin-bottom: 1rem; }

        /* Settings */
        .setting-row { margin-bottom: 1.5rem; }
        .setting-label { display: flex; justify-content: space-between; align-items: center; }
        .setting-value { color: var(--accent); }
        input[type="range"] { margin-top: 0.5rem; }
        input[type="checkbox"] { width: auto; margin-right: 0.5rem; }
        .type-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0.5rem 0.75rem; background: var(--bg-primary); border-radius: 6px;
            margin-bottom: 0.5rem; cursor: grab; user-select: none;
            transition: background-color 0.2s, transform 0.2s;
        }
        .type-item:active { cursor: grabbing; }
        .type-item.dragging { opacity: 0.5; transform: scale(1.02); }
        .type-item.drag-over { background: var(--bg-tertiary); border: 1px dashed var(--accent); }
        .type-item .drag-handle {
            color: var(--text-secondary); margin-right: 0.5rem; font-size: 1rem;
        }
        .type-item button {
            background: none; border: none; color: var(--text-secondary);
            cursor: pointer; padding: 0.25rem 0.5rem; font-size: 1rem;
        }
        .type-item button:hover { color: var(--accent); }

        /* Weekly Overview */
        .weekly-overview {
            margin-top: 2rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }
        .week-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .week-day {
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 0.5rem;
            min-height: 120px;
            min-width: 0;  /* Prevent grid blowout from long content */
            overflow: hidden;
        }
        .week-day-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-align: center;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--bg-tertiary);
            margin-bottom: 0.5rem;
            position: relative;
            cursor: pointer;
        }
        .week-day-header.today {
            color: var(--accent);
        }
        .week-day-section {
            margin-bottom: 0.5rem;
        }
        .week-day-section-label {
            font-size: 0.625rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 0.25rem;
            position: relative;
            cursor: pointer;
            display: inline-block;
            padding-right: 18px;
        }
        .week-day-section-label:hover {
            color: var(--text-primary);
        }
        .week-section-add-btn {
            display: none;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            border: none;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
            background: #22c55e;
            color: white;
        }
        .week-day-section-label:hover .week-section-add-btn {
            display: flex;
        }
        .week-section-add-btn:hover {
            opacity: 0.8;
        }
        .week-pomo {
            font-size: 0.625rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            margin-bottom: 0.15rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
            cursor: pointer;
        }
        .week-pomo:hover {
            overflow: visible;
            z-index: 10;
        }
        .week-pomo-controls {
            display: none;
            position: absolute;
            right: -2px;
            top: 50%;
            transform: translateY(-50%);
            gap: 2px;
            z-index: 20;
        }
        .week-pomo:hover .week-pomo-controls {
            display: flex;
        }
        .week-pomo-btn {
            width: 16px;
            height: 16px;
            border: none;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            line-height: 1;
        }
        .week-pomo-btn.add {
            background: #22c55e;
            color: white;
        }
        .week-pomo-btn.remove {
            background: #ef4444;
            color: white;
        }
        .week-pomo-btn:hover {
            opacity: 0.8;
        }
        /* Flatpickr dark theme customizations */
        .flatpickr-calendar {
            background: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        .flatpickr-calendar.arrowTop:after { border-bottom-color: var(--bg-secondary); }
        .flatpickr-calendar.arrowBottom:after { border-top-color: var(--bg-secondary); }
        .flatpickr-months .flatpickr-month { background: var(--bg-secondary); color: var(--text-primary); }
        .flatpickr-current-month .flatpickr-monthDropdown-months { background: var(--bg-secondary); color: var(--text-primary); }
        .flatpickr-current-month input.cur-year { color: var(--text-primary); }
        .flatpickr-months .flatpickr-prev-month, .flatpickr-months .flatpickr-next-month { color: var(--text-primary); fill: var(--text-primary); }
        .flatpickr-months .flatpickr-prev-month:hover, .flatpickr-months .flatpickr-next-month:hover { color: var(--accent); }
        .flatpickr-months .flatpickr-prev-month:hover svg, .flatpickr-months .flatpickr-next-month:hover svg { fill: var(--accent); }
        span.flatpickr-weekday { color: var(--text-secondary); background: var(--bg-secondary); }
        .flatpickr-day { color: var(--text-primary); }
        .flatpickr-day:hover { background: var(--bg-tertiary); border-color: var(--bg-tertiary); }
        .flatpickr-day.today { border-color: var(--accent); }
        .flatpickr-day.selected { background: var(--accent); border-color: var(--accent); }
        .flatpickr-day.prevMonthDay, .flatpickr-day.nextMonthDay { color: var(--text-secondary); }
        /* Remove time picker highlighting */
        .flatpickr-time { background: var(--bg-secondary); }
        .flatpickr-time input { background: transparent; color: var(--text-primary); }
        .flatpickr-time input:hover,
        .flatpickr-time input:focus { background: transparent; box-shadow: none; }
        .flatpickr-time .numInputWrapper:hover { background: transparent; }
        .flatpickr-time .numInputWrapper span.arrowUp:after,
        .flatpickr-time .numInputWrapper span.arrowDown:after { border-bottom-color: var(--text-secondary); border-top-color: var(--text-secondary); }
        .flatpickr-time .numInputWrapper span:hover { background: transparent; }
        .flatpickr-am-pm { background: transparent; color: var(--text-primary); }
        .flatpickr-am-pm:hover, .flatpickr-am-pm:focus { background: transparent; }
        .flatpickr-time input::selection { background: transparent; }
    </style>
</head>
<body>
    <div class="container">
        <header style="text-align: center; padding: 1rem 0;">
            <h1 style="font-size: 1.5rem; color: var(--text-primary); margin: 0;">Acquacotta</h1>
            <p style="font-size: 0.875rem; color: var(--text-secondary); margin: 0.25rem 0 0 0;">Pomodoro Tracker</p>
        </header>
        <nav>
            <button class="active" data-view="timer">Timer</button>
            <button data-view="reports">Reports</button>
            <button data-view="history">History</button>
            <button data-view="settings">Settings</button>
        </nav>

        <!-- Timer View -->
        <div id="timer-view" class="view active">
            <div class="timer-row">
                <!-- Weekly Overview -->
                <div class="weekly-overview">
                    <div style="display: flex; justify-content: center; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <button class="secondary" onclick="navigateWeek(-1)" style="padding: 0.25rem 0.75rem;">&larr;</button>
                        <h3 id="week-overview-label" style="margin: 0; color: var(--text-secondary); min-width: 150px; text-align: center;">This Week</h3>
                        <button class="secondary" onclick="navigateWeek(1)" style="padding: 0.25rem 0.75rem;">&rarr;</button>
                        <button class="secondary" onclick="goToCurrentWeek()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" title="Go to current week">Today</button>
                    </div>
                    <div class="week-grid" id="week-grid">
                        <!-- Days will be populated by JavaScript -->
                    </div>
                    <div class="week-chart-container" style="margin: 1rem 0;">
                        <canvas id="week-type-chart"></canvas>
                    </div>
                    <div style="text-align: center; color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.5rem;">
                        <span>Total Pomodoros: <span id="week-pomo-count">0</span></span>
                        <span style="margin-left: 1.5rem;">Total Minutes: <span id="week-minutes-count">0</span></span>
                    </div>
                </div>

                <div class="timer-container">
                    <div class="timer-display">
                        <svg viewBox="0 0 280 280" class="timer-ring">
                            <circle class="timer-ring-bg" cx="140" cy="140" r="120"/>
                            <circle id="timer-progress" class="timer-ring-progress" cx="140" cy="140" r="120"
                                stroke-dasharray="0 754" stroke-dashoffset="0"/>
                            <!-- Rounded end cap for timer band -->
                            <circle id="timer-end-cap" cx="140" cy="20" r="4" fill="var(--accent)" style="display: none;"/>
                            <!-- Tick marks: 25 ticks for 25 minutes (hidden by default, offset +90° for CSS rotation) -->
                            <g id="timer-ticks" class="timer-ticks" style="display: none;">
                                <!-- Major ticks every 5 minutes (0, 5, 10, 15, 20 min) at 90°, 162°, 234°, 306°, 18° -->
                                <line x1="140" y1="24" x2="140" y2="40" stroke-width="2" stroke="var(--text-primary)" transform="rotate(90 140 140)"/>
                                <line x1="140" y1="24" x2="140" y2="40" stroke-width="2" stroke="var(--text-primary)" transform="rotate(162 140 140)"/>
                                <line x1="140" y1="24" x2="140" y2="40" stroke-width="2" stroke="var(--text-primary)" transform="rotate(234 140 140)"/>
                                <line x1="140" y1="24" x2="140" y2="40" stroke-width="2" stroke="var(--text-primary)" transform="rotate(306 140 140)"/>
                                <line x1="140" y1="24" x2="140" y2="40" stroke-width="2" stroke="var(--text-primary)" transform="rotate(18 140 140)"/>
                                <!-- Minor ticks every minute (excluding 5-min boundaries, all +90°) -->
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(104.4 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(118.8 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(133.2 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(147.6 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(176.4 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(190.8 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(205.2 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(219.6 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(248.4 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(262.8 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(277.2 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(291.6 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(320.4 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(334.8 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(349.2 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(3.6 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(32.4 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(46.8 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(61.2 140 140)"/>
                                <line x1="140" y1="28" x2="140" y2="36" stroke="var(--text-secondary)" transform="rotate(75.6 140 140)"/>
                            </g>
                        </svg>
                        <div class="timer-text">
                            <div id="timer-time" class="timer-time">25:00</div>
                            <div id="timer-status" class="timer-status">Ready</div>
                        </div>
                    </div>
                    <div class="duration-presets" id="duration-presets">
                        <button data-preset="1">5</button>
                        <button data-preset="2">10</button>
                        <button data-preset="3">15</button>
                        <button data-preset="4" class="active">25</button>
                    </div>
                    <!-- Break Presets -->
                    <div class="break-presets" id="break-presets">
                        <button id="btn-short-break">5</button>
                        <button id="btn-long-break">15</button>
                    </div>
                    <!-- Break Info -->
                    <div class="break-info" id="break-info">
                        <div class="break-progress-bar" id="break-progress-bar"></div>
                        <div id="break-progress">1/4 until long break</div>
                    </div>
                    <!-- Pomodoro Details -->
                    <div class="timer-details">
                        <input type="text" id="timer-pomo-name" placeholder="What are you working on? (optional)" style="width: 100%; margin-bottom: 0.5rem;">
                        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <select id="timer-pomo-type" style="flex: 1;"></select>
                        </div>
                        <textarea id="timer-pomo-notes" placeholder="Notes (optional)" rows="2" style="width: 100%; resize: none;"></textarea>
                    </div>
                    <div class="timer-controls">
                        <button id="btn-start" class="primary">Start</button>
                        <button id="btn-pause" class="secondary" style="display:none;">Pause</button>
                        <button id="btn-resume" class="primary" style="display:none;">Resume</button>
                        <button id="btn-stop" class="secondary" style="display:none;">Stop</button>
                        <button id="btn-discard" class="secondary" style="display:none;">Discard</button>
                    </div>
                    <!-- Clock -->
                    <div id="clock-display" style="text-align: center; margin-top: 1rem; padding: 0.75rem; background: var(--bg-primary); border-radius: 8px;">
                        <div id="clock-time" style="font-size: 1.5rem; font-weight: 300; font-variant-numeric: tabular-nums; color: var(--text-primary);"></div>
                        <div id="clock-date" style="font-size: 0.75rem; color: var(--text-secondary);"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- History View -->
        <div id="history-view" class="view">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>History</h2>
                <button class="secondary" onclick="showAddModal()">+ Add Manual</button>
            </div>
            <div id="history-list"></div>
        </div>

        <!-- Reports View -->
        <div id="reports-view" class="view">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>Reports</h2>
                <a href="/api/export" class="secondary" style="text-decoration:none; display:inline-block; padding:0.75rem 1.5rem; background:var(--bg-tertiary); border-radius:8px; color:var(--text-primary);">Export CSV</a>
            </div>
            <div class="period-selector">
                <button data-period="day">Day</button>
                <button class="active" data-period="week">Week</button>
                <button data-period="month">Month</button>
            </div>
            <div class="period-nav">
                <button class="secondary" onclick="navigatePeriod(-1)">&larr;</button>
                <span id="period-label" style="min-width: 200px; text-align: center;"></span>
                <button class="secondary" onclick="navigatePeriod(1)">&rarr;</button>
                <button class="secondary" onclick="goToCurrentPeriod()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem;" title="Go to current period">Today</button>
            </div>
            <div class="summary-cards">
                <div class="card summary-card">
                    <span id="report-count" class="summary-value">0</span>
                    <span class="summary-label">Pomodoros</span>
                </div>
                <div class="card summary-card">
                    <span id="report-time" class="summary-value">0m</span>
                    <span class="summary-label">Total Time</span>
                </div>
                <div class="card summary-card">
                    <span id="report-avg" class="summary-value">0m</span>
                    <span class="summary-label">Avg Duration</span>
                </div>
            </div>
            <div class="card">
                <h3>Daily Activity (Minutes)</h3>
                <div class="chart-container"><canvas id="chart-daily"></canvas></div>
            </div>
            <div class="card">
                <h3>By Type (Minutes)</h3>
                <div class="chart-container"><canvas id="chart-type"></canvas></div>
            </div>
        </div>

        <!-- Settings View -->
        <div id="settings-view" class="view">
            <h2>Settings</h2>
            <div class="card" id="google-account-card">
                <h3>Google Sheets Sync (Optional)</h3>
                <div id="google-logged-out">
                    <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem;">
                        Your data is stored locally by default. Optionally sign in with Google to sync your data to Google Sheets.
                    </p>
                    <button class="primary" onclick="window.location.href='/auth/google'" id="google-login-btn">
                        Sign in with Google
                    </button>
                    <p id="google-not-configured" style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 0.5rem; display: none;">
                        Google OAuth is not configured. See README for setup instructions.
                    </p>
                </div>
                <div id="google-logged-in" style="display: none;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <img id="google-avatar" src="" alt="" style="width: 40px; height: 40px; border-radius: 50%;">
                        <div>
                            <div id="google-name" style="font-weight: 500;"></div>
                            <div id="google-email" style="font-size: 0.875rem; color: var(--text-secondary);"></div>
                        </div>
                    </div>
                    <p style="color: var(--success); font-size: 0.875rem; margin-bottom: 1rem;">
                        ✓ Data synced to Google Sheets
                    </p>
                    <div style="margin-bottom: 1rem;">
                        <label for="spreadsheet-id" style="font-size: 0.875rem; color: var(--text-secondary); display: block; margin-bottom: 0.25rem;">Spreadsheet ID:</label>
                        <div style="display: flex; gap: 0.5rem;">
                            <input type="text" id="spreadsheet-id" style="flex: 1; font-family: monospace; font-size: 0.75rem; padding: 0.5rem;" placeholder="Spreadsheet ID">
                            <button class="secondary" onclick="updateSpreadsheetId()" style="white-space: nowrap;">Update</button>
                        </div>
                        <p id="spreadsheet-id-status" style="font-size: 0.75rem; margin-top: 0.25rem; display: none;"></p>
                    </div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                        <button class="secondary" onclick="refreshFromSheets()">Refresh Data</button>
                        <button class="secondary" onclick="migrateData()">Migrate Local Data</button>
                        <button class="secondary" onclick="window.location.href='/auth/logout'">Sign Out</button>
                    </div>
                    <p id="migrate-status" style="font-size: 0.875rem; margin-top: 0.5rem; display: none;"></p>
                </div>
            </div>
            <div class="card">
                <h3>Timer Presets</h3>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Preset 1</span>
                        <span id="preset1-value" class="setting-value">5 min</span>
                    </div>
                    <input type="range" id="preset1-duration" min="1" max="60" value="5">
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Preset 2</span>
                        <span id="preset2-value" class="setting-value">10 min</span>
                    </div>
                    <input type="range" id="preset2-duration" min="1" max="60" value="10">
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Preset 3</span>
                        <span id="preset3-value" class="setting-value">15 min</span>
                    </div>
                    <input type="range" id="preset3-duration" min="1" max="60" value="15">
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Preset 4</span>
                        <span id="preset4-value" class="setting-value">25 min</span>
                    </div>
                    <input type="range" id="preset4-duration" min="1" max="60" value="25">
                </div>
            </div>
            <div class="card">
                <h3>Breaks</h3>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Short Break</span>
                        <span id="short-break-value" class="setting-value">5 min</span>
                    </div>
                    <input type="range" id="short-break" min="1" max="30" value="5">
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Long Break</span>
                        <span id="long-break-value" class="setting-value">15 min</span>
                    </div>
                    <input type="range" id="long-break" min="1" max="60" value="15">
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Long break after</span>
                        <span id="long-break-after-value" class="setting-value">4 pomodoros</span>
                    </div>
                    <input type="range" id="long-break-after" min="2" max="10" value="4">
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="always-short-break"> Always use short breaks</span>
                    </label>
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="auto-start-after-break"> Auto-start next pomodoro after break</span>
                    </label>
                </div>
            </div>
            <div class="card">
                <h3>Sound</h3>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="tick-sound-enabled" checked> Enable tick sound (60 Minutes style)</span>
                    </label>
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="tick-sound-during-breaks"> Play tick sound during breaks</span>
                    </label>
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="bell-at-pomodoro-end" checked> Play bell at end of pomodoro</span>
                    </label>
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="bell-at-break-end" checked> Play bell at end of break</span>
                    </label>
                </div>
                <div class="setting-row">
                    <div class="setting-label">
                        <span>Volume</span>
                        <span id="tick-volume-value" class="setting-value">50%</span>
                    </div>
                    <input type="range" id="tick-volume" min="0" max="100" value="50">
                </div>
            </div>
            <div class="card">
                <h3>Display</h3>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="show-timer-ticks"> Show minute tick marks on timer</span>
                    </label>
                </div>
                <div class="setting-row">
                    <label for="timer-snap-interval">Timer drag snap interval</label>
                    <select id="timer-snap-interval" style="margin-top: 0.5rem;">
                        <option value="1">1 second (no snap)</option>
                        <option value="30">30 seconds</option>
                        <option value="60" selected>1 minute</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label class="setting-label" style="cursor: pointer;">
                        <span><input type="checkbox" id="show-notes-field" checked> Show notes field</span>
                    </label>
                </div>
            </div>
            <div class="card">
                <h3>Clock</h3>
                <div class="setting-row">
                    <label for="timezone">Timezone</label>
                    <select id="timezone" style="margin-top: 0.5rem;"></select>
                </div>
                <div class="setting-row">
                    <label for="date-format">Date Format</label>
                    <select id="date-format" style="margin-top: 0.5rem;">
                        <option value="us">US (MM/DD/YYYY)</option>
                        <option value="eu">European (DD/MM/YYYY)</option>
                        <option value="iso">ISO (YYYY-MM-DD)</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label for="clock-format">Clock Format</label>
                    <select id="clock-format" style="margin-top: 0.5rem;">
                        <option value="auto">Auto (based on date format)</option>
                        <option value="12">12-hour (AM/PM)</option>
                        <option value="24">24-hour</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label for="period-labels">Period Labels</label>
                    <select id="period-labels" style="margin-top: 0.5rem;">
                        <option value="auto">Auto (based on date format)</option>
                        <option value="ampm">AM / PM</option>
                        <option value="morning">Morning / Afternoon</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>Working Hours</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-top: 0.5rem;">
                        <input type="text" id="working-hours-start" style="width: 100px;" placeholder="08:00">
                        <span style="color: var(--text-secondary);">to</span>
                        <input type="text" id="working-hours-end" style="width: 100px;" placeholder="17:00">
                    </div>
                </div>
                <div class="setting-row">
                    <label for="daily-minutes-goal">Daily Minutes Goal</label>
                    <input type="number" id="daily-minutes-goal" min="0" max="600" style="width: 100px; margin-top: 0.5rem;" placeholder="200">
                </div>
            </div>
            <div class="card">
                <h3>Pomodoro Types</h3>
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem;">Configure the types of work you track. Drag to reorder.</p>
                <div id="types-list" style="margin-bottom: 1rem;"></div>
                <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <input type="text" id="new-type-input" placeholder="Add new type..." style="flex: 1;">
                    <button class="secondary" onclick="addNewType()">Add</button>
                </div>
                <button class="secondary" onclick="sortTypesAlphabetically()" style="width: 100%;">Sort A-Z</button>
            </div>
            <p style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; margin-top: 1rem;">Settings are saved automatically</p>
        </div>

        <footer style="text-align: center; padding: 2rem 0 1rem; margin-top: 2rem; border-top: 1px solid var(--border-color);">
            <a href="/privacy" style="color: var(--text-secondary); font-size: 0.75rem; text-decoration: none; margin: 0 1rem;">Privacy Policy</a>
            <a href="/terms" style="color: var(--text-secondary); font-size: 0.75rem; text-decoration: none; margin: 0 1rem;">Terms of Service</a>
        </footer>
    </div>

    <!-- Add Manual Modal -->
    <div id="add-modal" class="modal-overlay">
        <div class="modal">
            <h2>Add Manual Pomodoro</h2>
            <div class="form-group">
                <label for="add-name">Description (optional)</label>
                <input type="text" id="add-name" placeholder="What did you work on?">
            </div>
            <div class="form-group">
                <label for="add-type">Type</label>
                <select id="add-type"></select>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group">
                    <label for="add-date">Date</label>
                    <input type="date" id="add-date">
                </div>
                <div class="form-group">
                    <label>Start Time</label>
                    <input type="text" id="add-time" placeholder="09:00">
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group">
                    <label for="add-duration">Duration (minutes)</label>
                    <input type="number" id="add-duration" value="25" min="1" max="120">
                </div>
                <div class="form-group">
                    <label for="add-count">Count</label>
                    <input type="number" id="add-count" value="1" min="1" max="20">
                </div>
            </div>
            <p id="add-preview" style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 1rem;"></p>
            <p id="add-error" style="font-size: 0.75rem; color: var(--accent); margin-bottom: 1rem; display: none;"></p>
            <div class="modal-actions">
                <button class="secondary" onclick="hideAddModal()">Cancel</button>
                <button class="primary" onclick="addManualPomodoro()">Add</button>
            </div>
        </div>
    </div>

    <!-- Migration Modal (manual trigger from settings) -->
    <div id="migrate-modal" class="modal-overlay">
        <div class="modal">
            <h2>Migrate Local Data</h2>
            <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem;">
                This will copy your local pomodoros to Google Sheets. Duplicates will be skipped.
            </p>
            <div class="form-group">
                <label>Settings Sync Direction</label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="radio" name="settings-direction" value="sheets_to_local" checked>
                        <span>Use Google Sheets settings (recommended)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="radio" name="settings-direction" value="local_to_sheets">
                        <span>Overwrite Google Sheets with local settings</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="radio" name="settings-direction" value="skip">
                        <span>Skip settings (only migrate pomodoros)</span>
                    </label>
                </div>
            </div>
            <div class="modal-actions">
                <button class="secondary" onclick="hideMigrateModal()">Cancel</button>
                <button class="primary" onclick="runMigration()">Migrate</button>
            </div>
        </div>
    </div>

    <!-- Initial Sync Modal (shown on login to choose sync direction) -->
    <div id="initial-sync-modal" class="modal-overlay">
        <div class="modal">
            <h2 id="sync-modal-title">Sync Your Data</h2>
            <p id="sync-modal-desc" style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem;"></p>
            <p id="sync-counts" style="font-size: 0.875rem; margin-bottom: 1rem;"></p>
            <div id="sync-modal-actions" class="modal-actions"></div>
        </div>
    </div>

    <!-- Edit Pomodoro Modal -->
    <div id="edit-modal" class="modal-overlay">
        <div class="modal">
            <h2>Edit Pomodoro</h2>
            <input type="hidden" id="edit-id">
            <div class="form-group">
                <label for="edit-name">Description (optional)</label>
                <input type="text" id="edit-name" placeholder="What did you work on?">
            </div>
            <div class="form-group">
                <label for="edit-type">Type</label>
                <select id="edit-type"></select>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div class="form-group">
                    <label for="edit-date">Date</label>
                    <input type="date" id="edit-date">
                </div>
                <div class="form-group">
                    <label>Start Time</label>
                    <input type="text" id="edit-time" placeholder="09:00">
                </div>
            </div>
            <div class="form-group">
                <label for="edit-duration">Duration (minutes)</label>
                <input type="number" id="edit-duration" min="1" max="120">
            </div>
            <div class="form-group">
                <label for="edit-notes">Notes</label>
                <textarea id="edit-notes" rows="2" placeholder="Notes (optional)"></textarea>
            </div>
            <div class="modal-actions">
                <button class="secondary" onclick="hideEditModal()">Cancel</button>
                <button class="primary" onclick="saveEditedPomodoro()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // Type colors
        const TYPE_COLORS = {
            "Product": "#e94560",
            "Customer/Partner/Community": "#4ecca3",
            "Content": "#ffc93c",
            "Team": "#a855f7",
            "Social Media": "#3b82f6",
            "Unqueued": "#6b7280",
            "Queued": "#8b5cf6",
            "Learn/Train": "#10b981",
            "Travel": "#f97316",
            "PTO": "#06b6d4"
        };

        // Common timezones
        const TIMEZONES = [
            { value: 'Pacific/Honolulu', label: 'Hawaii (HST)' },
            { value: 'America/Anchorage', label: 'Alaska (AKST)' },
            { value: 'America/Los_Angeles', label: 'Pacific (PST)' },
            { value: 'America/Denver', label: 'Mountain (MST)' },
            { value: 'America/Chicago', label: 'Central (CST)' },
            { value: 'America/New_York', label: 'Eastern (EST)' },
            { value: 'America/Halifax', label: 'Atlantic (AST)' },
            { value: 'America/St_Johns', label: 'Newfoundland (NST)' },
            { value: 'America/Sao_Paulo', label: 'Brasilia (BRT)' },
            { value: 'Atlantic/Azores', label: 'Azores (AZOT)' },
            { value: 'Europe/London', label: 'London (GMT/BST)' },
            { value: 'Europe/Paris', label: 'Paris (CET)' },
            { value: 'Europe/Berlin', label: 'Berlin (CET)' },
            { value: 'Europe/Moscow', label: 'Moscow (MSK)' },
            { value: 'Asia/Dubai', label: 'Dubai (GST)' },
            { value: 'Asia/Kolkata', label: 'India (IST)' },
            { value: 'Asia/Bangkok', label: 'Bangkok (ICT)' },
            { value: 'Asia/Shanghai', label: 'China (CST)' },
            { value: 'Asia/Tokyo', label: 'Tokyo (JST)' },
            { value: 'Australia/Sydney', label: 'Sydney (AEST)' },
            { value: 'Pacific/Auckland', label: 'New Zealand (NZST)' },
        ];

        // Timer state
        let timerState = 'idle';
        let remainingSeconds = 25 * 60;
        let totalSeconds = 25 * 60;
        let timerInterval = null;
        let sessionCount = 1;
        let clockInterval = null;
        let isBreak = false;
        let lastPomodoro = { type: null, name: null, notes: null };
        let weekOverviewOffset = 0; // 0 = this week, -1 = last week, etc.
        let selectedPreset = 4; // Which duration preset is selected (1-4)
        let pomodorosCompleted = 0; // Count for long break logic

        // Drag state for slidable timer
        let isDragging = false;
        let settings = {
            timer_preset_1: 5,
            timer_preset_2: 10,
            timer_preset_3: 15,
            timer_preset_4: 25,
            short_break_minutes: 5,
            long_break_minutes: 15,
            pomodoros_until_long_break: 4,
            always_use_short_break: false,
            tick_sound_enabled: true,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            date_format: 'us',
            auto_start_after_break: false,
            tick_sound_during_breaks: false,
            bell_at_pomodoro_end: true,
            bell_at_break_end: true,
            pomodoro_types: [],
            show_timer_ticks: false,
            timer_snap_interval: 60 // seconds: 1, 30, or 60
        };

        // Bell sound using Web Audio API
        let audioContext = null;
        function playBellSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const now = audioContext.currentTime;

            // Create a bell-like sound with multiple harmonics
            const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5 chord

            frequencies.forEach((freq, i) => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = freq;
                oscillator.type = 'sine';

                // Bell envelope: quick attack, slow decay
                const volume = (settings.tick_volume ?? 50) / 100 * 0.3;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(volume, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + 1.5);

                oscillator.start(now + i * 0.05);
                oscillator.stop(now + 1.5);
            });
        }

        // Flatpickr date picker instances
        let addDatePicker = null;
        let editDatePicker = null;

        // Initialize or reinitialize Flatpickr with locale-aware week start
        function initDatePickers() {
            // US = Sunday first (0), EU/ISO = Monday first (1)
            const firstDay = settings.date_format === 'us' ? 0 : 1;

            // Date format for display
            const dateFormat = settings.date_format === 'eu' ? 'd/m/Y' :
                               settings.date_format === 'iso' ? 'Y-m-d' : 'm/d/Y';

            const config = {
                dateFormat: 'Y-m-d',  // Internal format stays the same
                altInput: true,
                altFormat: dateFormat,
                locale: { firstDayOfWeek: firstDay },
                disableMobile: true  // Force calendar on mobile too
            };

            // Destroy existing instances if they exist
            if (addDatePicker) addDatePicker.destroy();
            if (editDatePicker) editDatePicker.destroy();

            // Initialize new instances
            addDatePicker = flatpickr('#add-date', config);
            editDatePicker = flatpickr('#edit-date', config);
        }

        // Time picker instances
        let addTimePicker = null;
        let editTimePicker = null;
        let workingHoursStartPicker = null;
        let workingHoursEndPicker = null;

        function initTimePickers() {
            // Determine if we should use 12-hour format
            const is12Hour = settings.clock_format === '12' ||
                             (settings.clock_format !== '24' && settings.date_format === 'us');

            const timeConfig = {
                enableTime: true,
                noCalendar: true,
                dateFormat: 'H:i',  // Always store in 24-hour format
                altInput: true,
                altFormat: is12Hour ? 'h:i K' : 'H:i',  // Display format based on setting
                time_24hr: !is12Hour,
                minuteIncrement: 30,
                disableMobile: true
            };

            // Destroy existing instances if they exist
            if (addTimePicker) addTimePicker.destroy();
            if (editTimePicker) editTimePicker.destroy();
            if (workingHoursStartPicker) workingHoursStartPicker.destroy();
            if (workingHoursEndPicker) workingHoursEndPicker.destroy();

            // Initialize new instances
            addTimePicker = flatpickr('#add-time', {
                ...timeConfig,
                defaultDate: '09:00',
                onChange: function() { updateAddPreview(); }
            });
            editTimePicker = flatpickr('#edit-time', timeConfig);
            workingHoursStartPicker = flatpickr('#working-hours-start', {
                ...timeConfig,
                defaultDate: settings.working_hours_start || '08:00',
                onChange: function(selectedDates, dateStr) {
                    settings.working_hours_start = dateStr;
                    autoSaveSettings();
                }
            });
            workingHoursEndPicker = flatpickr('#working-hours-end', {
                ...timeConfig,
                defaultDate: settings.working_hours_end || '17:00',
                onChange: function(selectedDates, dateStr) {
                    settings.working_hours_end = dateStr;
                    autoSaveSettings();
                }
            });
        }

        // Date formatting helper
        function formatDate(date, format) {
            const d = new Date(date);
            const day = d.getDate();
            const month = d.getMonth() + 1;
            const year = d.getFullYear();
            const fmt = format || settings.date_format || 'us';

            if (fmt === 'eu') {
                return `${day}/${month}/${year}`;
            } else if (fmt === 'iso') {
                return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            } else {
                // US format (default)
                return `${month}/${day}/${year}`;
            }
        }

        function formatDateWithDay(date, format) {
            const d = new Date(date);
            const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const dayName = dayNames[d.getDay()];
            const day = d.getDate();
            const month = d.getMonth() + 1;
            const monthName = monthNames[d.getMonth()];
            const year = d.getFullYear();
            const fmt = format || settings.date_format || 'us';

            if (fmt === 'eu') {
                return `${dayName}, ${day} ${monthName}`;
            } else if (fmt === 'iso') {
                return `${dayName}, ${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            } else {
                // US format (default)
                return `${dayName}, ${monthName} ${day}`;
            }
        }

        // Clock functions
        function populateTimezoneDropdown() {
            const select = document.getElementById('timezone');
            const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;

            // Add browser's timezone first if not in list
            const inList = TIMEZONES.some(tz => tz.value === browserTz);
            if (!inList) {
                const option = document.createElement('option');
                option.value = browserTz;
                option.textContent = `${browserTz} (Local)`;
                select.appendChild(option);
            }

            TIMEZONES.forEach(tz => {
                const option = document.createElement('option');
                option.value = tz.value;
                option.textContent = tz.label;
                if (tz.value === browserTz) {
                    option.textContent += ' (Local)';
                }
                select.appendChild(option);
            });

            select.value = settings.timezone || browserTz;
        }

        function updateClock() {
            const tz = settings.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
            const now = new Date();

            // Determine 12-hour or 24-hour format
            let hour12;
            if (settings.clock_format === '12') {
                hour12 = true;
            } else if (settings.clock_format === '24') {
                hour12 = false;
            } else {
                // Auto: use 12-hour for US, 24-hour for EU/ISO
                hour12 = settings.date_format === 'us';
            }

            const timeOptions = {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: hour12,
                timeZone: tz
            };
            const dateOptions = {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                timeZone: tz
            };

            document.getElementById('clock-time').textContent = now.toLocaleTimeString('en-US', timeOptions);
            document.getElementById('clock-date').textContent = now.toLocaleDateString('en-US', dateOptions);
        }

        function startClock() {
            updateClock();
            clockInterval = setInterval(updateClock, 1000);
        }

        // Weekly Overview functions
        function navigateWeek(dir) {
            weekOverviewOffset += dir;
            loadWeeklyOverview();
        }

        function goToCurrentWeek() {
            weekOverviewOffset = 0;
            loadWeeklyOverview();
        }

        async function loadWeeklyOverview() {
            const tz = settings.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
            const now = new Date();

            // US = Sunday first, EU/ISO = Monday first
            const sundayFirst = settings.date_format === 'us';

            // Get start of current week
            const startOfWeek = new Date(now);
            if (sundayFirst) {
                // Sunday first: go back to Sunday (getDay() = 0 for Sunday)
                startOfWeek.setDate(now.getDate() - now.getDay());
            } else {
                // Monday first: go back to Monday
                // (getDay() + 6) % 7 gives days since Monday (Mon=0, Tue=1, ..., Sun=6)
                const daysSinceMonday = (now.getDay() + 6) % 7;
                startOfWeek.setDate(now.getDate() - daysSinceMonday);
            }
            startOfWeek.setHours(0, 0, 0, 0);

            // Apply week offset
            startOfWeek.setDate(startOfWeek.getDate() + (weekOverviewOffset * 7));

            // Get end of week (7 days later)
            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 7);

            // Update week label
            const weekLabel = document.getElementById('week-overview-label');
            if (weekOverviewOffset === 0) {
                weekLabel.textContent = 'This Week';
            } else if (weekOverviewOffset === -1) {
                weekLabel.textContent = 'Last Week';
            } else {
                // Format date range
                const startMonth = startOfWeek.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const endDate = new Date(endOfWeek);
                endDate.setDate(endDate.getDate() - 1); // End of week is exclusive, so subtract 1
                const endMonth = endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                weekLabel.textContent = `${startMonth} - ${endMonth}`;
            }

            const startISO = startOfWeek.toISOString();
            const endISO = endOfWeek.toISOString();

            try {
                const res = await fetch(`/api/pomodoros?start_date=${startISO}&end_date=${endISO}`);
                const pomodoros = await res.json();
                renderWeeklyGrid(pomodoros, startOfWeek, tz, sundayFirst);
                renderWeeklySummary(pomodoros);
            } catch (e) {
                console.error('Failed to load weekly overview:', e);
            }
        }

        function renderWeeklyGrid(pomodoros, startOfWeek, tz, sundayFirst) {
            const grid = document.getElementById('week-grid');
            // Day names in order based on week start
            const days = sundayFirst
                ? ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
                : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const today = new Date();
            const todayStr = today.toLocaleDateString('en-CA', { timeZone: tz });

            let html = '';
            for (let i = 0; i < 7; i++) {
                const dayDate = new Date(startOfWeek);
                dayDate.setDate(startOfWeek.getDate() + i);
                const dayStr = dayDate.toLocaleDateString('en-CA', { timeZone: tz });
                const isToday = dayStr === todayStr;
                const dayNum = dayDate.getDate();

                // Filter pomodoros for this day
                const dayPomos = pomodoros.filter(p => {
                    const pomoDate = new Date(p.start_time);
                    return pomoDate.toLocaleDateString('en-CA', { timeZone: tz }) === dayStr;
                });

                // Split into AM/PM (noon = 12:00)
                const amPomos = dayPomos.filter(p => {
                    const h = new Date(p.start_time).getHours();
                    return h < 12;
                });
                const pmPomos = dayPomos.filter(p => {
                    const h = new Date(p.start_time).getHours();
                    return h >= 12;
                });

                // Determine period labels based on setting
                // Auto: US = AM/PM, EU/ISO = Morning/Afternoon
                const useMorningLabels = settings.period_labels === 'morning' ||
                    (settings.period_labels !== 'ampm' && settings.date_format !== 'us');
                const amLabel = useMorningLabels ? 'Morning' : 'AM';
                const pmLabel = useMorningLabels ? 'Afternoon' : 'PM';

                html += `<div class="week-day">
                    <div class="week-day-header ${isToday ? 'today' : ''}">
                        ${days[i]} ${dayNum}
                    </div>
                    <div class="week-day-section">
                        <div class="week-day-section-label" onclick="addPomoToNextSlot('${dayStr}', true)">
                            ${amLabel}
                            <button class="week-section-add-btn" title="Add to next available slot">+</button>
                        </div>
                        ${renderDayPomos(amPomos, dayStr, true)}
                    </div>
                    <div class="week-day-section">
                        <div class="week-day-section-label" onclick="addPomoToNextSlot('${dayStr}', false)">
                            ${pmLabel}
                            <button class="week-section-add-btn" title="Add to next available slot">+</button>
                        </div>
                        ${renderDayPomos(pmPomos, dayStr, false)}
                    </div>
                </div>`;
            }
            grid.innerHTML = html;
        }

        function renderDayPomos(pomos, dayStr, isAM) {
            if (pomos.length === 0) return '<div style="color: var(--text-secondary); font-size: 0.625rem;">—</div>';

            // Sort pomodoros by start time first
            const sortedPomos = [...pomos].sort((a, b) =>
                new Date(a.start_time) - new Date(b.start_time)
            );

            // Group by type + name, tracking earliest time and all IDs for each group
            const byTypeAndName = {};
            sortedPomos.forEach(p => {
                const key = `${p.type}|||${p.name || ''}`;
                if (!byTypeAndName[key]) {
                    byTypeAndName[key] = {
                        type: p.type,
                        name: p.name || '',
                        count: 0,
                        earliestTime: p.start_time,
                        ids: []
                    };
                }
                byTypeAndName[key].count++;
                byTypeAndName[key].ids.push({ id: p.id, start_time: p.start_time });
            });

            // Sort groups by earliest time
            const sortedGroups = Object.values(byTypeAndName).sort((a, b) =>
                new Date(a.earliestTime) - new Date(b.earliestTime)
            );

            let html = '';
            for (const item of sortedGroups) {
                const color = TYPE_COLORS[item.type] || '#6b7280';
                const displayName = item.name || item.type;
                const label = item.count > 1
                    ? `${displayName}: ${item.count}`
                    : displayName;
                // Sort IDs by start_time descending so we can delete latest first
                const sortedIds = item.ids.sort((a, b) => new Date(b.start_time) - new Date(a.start_time));
                const idsJson = JSON.stringify(sortedIds.map(i => i.id)).replace(/"/g, '&quot;');
                const typeEsc = item.type.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                const nameEsc = item.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                // Get the latest pomodoro ID for navigation
                const latestId = sortedIds[0].id.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                html += `<div class="week-pomo" style="background: ${color}30; color: ${color};" title="${item.type}: ${item.name || '(no name)'}" onclick="navigateToPomodoro('${latestId}')">
                    <span class="week-pomo-label">${label}</span>
                    <div class="week-pomo-controls">
                        <button class="week-pomo-btn remove" onclick="event.stopPropagation(); decrementPomoBlock(${idsJson})" title="Remove latest">−</button>
                        <button class="week-pomo-btn add" onclick="event.stopPropagation(); incrementPomoBlock('${typeEsc}', '${nameEsc}', '${dayStr}', ${isAM})" title="Add another">+</button>
                    </div>
                </div>`;
            }
            return html;
        }

        // Add a pomodoro of the same type/name on the specified day in a free slot
        async function incrementPomoBlock(type, name, dayStr, isAM) {
            // Get the selected duration from settings
            const duration = settings[`timer_preset_${selectedPreset}`] || 25;

            // Use working hours settings
            const workStart = settings.working_hours_start || '08:00';
            const workEnd = settings.working_hours_end || '17:00';
            const [workStartHour, workStartMin] = workStart.split(':').map(Number);
            const [workEndHour, workEndMin] = workEnd.split(':').map(Number);

            // Find a free time slot on that day
            // For AM: try slots from working hours start to 12:00 (every 30 min)
            // For PM: try slots from 12:00 to working hours end (every 30 min)
            const startHour = isAM ? workStartHour : 12;
            const startMin = isAM ? workStartMin : 0;
            const endHour = isAM ? 12 : workEndHour;
            const endMin = isAM ? 0 : workEndMin;

            // Fetch existing pomodoros for that day to find free slots
            const dayStart = new Date(dayStr + 'T00:00:00');
            const dayEnd = new Date(dayStr + 'T23:59:59');

            try {
                const res = await fetch(`/api/pomodoros?start_date=${dayStart.toISOString()}&end_date=${dayEnd.toISOString()}`);
                const existingPomos = await res.json();

                // Find occupied time ranges
                const occupied = existingPomos.map(p => ({
                    start: new Date(p.start_time),
                    end: new Date(p.end_time)
                }));

                // Try to find a free slot (every 30 min)
                let freeSlotStart = null;
                const startTimeMinutes = startHour * 60 + startMin;
                const endTimeMinutes = endHour * 60 + endMin;

                for (let timeMinutes = startTimeMinutes; timeMinutes < endTimeMinutes; timeMinutes += 30) {
                    const hour = Math.floor(timeMinutes / 60);
                    const min = timeMinutes % 60;
                    const slotStart = new Date(dayStr + 'T' + String(hour).padStart(2, '0') + ':' + String(min).padStart(2, '0') + ':00');
                    const slotEnd = new Date(slotStart.getTime() + duration * 60 * 1000);

                    // Check if this slot overlaps with any existing pomodoro
                    const isOccupied = occupied.some(o =>
                        (slotStart < o.end && slotEnd > o.start)
                    );

                    if (!isOccupied) {
                        freeSlotStart = slotStart;
                        break;
                    }
                }

                if (!freeSlotStart) {
                    return;
                }

                const endTime = new Date(freeSlotStart.getTime() + duration * 60 * 1000);

                // Create the pomodoro using the manual endpoint
                const response = await fetch('/api/pomodoros/manual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: type,
                        name: name,
                        start_time: freeSlotStart.toISOString(),
                        end_time: endTime.toISOString(),
                        duration_minutes: duration
                    })
                });

                if (response.ok) {
                    await loadWeeklyOverview();
                }
            } catch (e) {
                console.error('Error adding pomodoro:', e);
            }
        }

        // Delete the latest pomodoro from a group (first ID in the array is the latest)
        async function decrementPomoBlock(ids) {
            if (!ids || ids.length === 0) return;

            // The first ID is the latest (sorted by start_time descending)
            const latestId = ids[0];

            try {
                const response = await fetch(`/api/pomodoros/${latestId}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    await loadWeeklyOverview();
                }
            } catch (e) {
                console.error('Error deleting pomodoro:', e);
            }
        }

        // Add a pomodoro to the next available slot in morning or afternoon
        async function addPomoToNextSlot(dayStr, isMorning) {
            // Get the selected duration from settings
            const duration = settings[`timer_preset_${selectedPreset}`] || 25;

            // Use working hours settings
            const workStart = settings.working_hours_start || '08:00';
            const workEnd = settings.working_hours_end || '17:00';
            const [workStartHour, workStartMin] = workStart.split(':').map(Number);
            const [workEndHour, workEndMin] = workEnd.split(':').map(Number);

            // For Morning: from working hours start to 12:00
            // For Afternoon: from 12:00 to working hours end
            const startHour = isMorning ? workStartHour : 12;
            const startMin = isMorning ? workStartMin : 0;
            const endHour = isMorning ? 12 : workEndHour;
            const endMin = isMorning ? 0 : workEndMin;

            // Fetch existing pomodoros for that day to find free slots
            const dayStart = new Date(dayStr + 'T00:00:00');
            const dayEnd = new Date(dayStr + 'T23:59:59');

            try {
                const res = await fetch(`/api/pomodoros?start_date=${dayStart.toISOString()}&end_date=${dayEnd.toISOString()}`);
                const existingPomos = await res.json();

                // Find occupied time ranges
                const occupied = existingPomos.map(p => ({
                    start: new Date(p.start_time),
                    end: new Date(p.end_time)
                }));

                // Try to find a free slot (every 30 min)
                let freeSlotTime = null;
                const startTimeMinutes = startHour * 60 + startMin;
                const endTimeMinutes = endHour * 60 + endMin;

                for (let timeMinutes = startTimeMinutes; timeMinutes < endTimeMinutes; timeMinutes += 30) {
                    const hour = Math.floor(timeMinutes / 60);
                    const min = timeMinutes % 60;
                    const slotStart = new Date(dayStr + 'T' + String(hour).padStart(2, '0') + ':' + String(min).padStart(2, '0') + ':00');
                    const slotEnd = new Date(slotStart.getTime() + duration * 60 * 1000);

                    // Check if this slot overlaps with any existing pomodoro
                    const isOccupied = occupied.some(o =>
                        (slotStart < o.end && slotEnd > o.start)
                    );

                    if (!isOccupied) {
                        freeSlotTime = String(hour).padStart(2, '0') + ':' + String(min).padStart(2, '0');
                        break;
                    }
                }

                // Open add modal with the date and time pre-filled
                const date = new Date(dayStr + 'T' + (freeSlotTime || workStart) + ':00');
                if (addDatePicker) {
                    addDatePicker.setDate(date, true);
                }
                if (addTimePicker) {
                    addTimePicker.setDate(freeSlotTime || workStart, true);
                }
                document.getElementById('add-count').value = '1';
                document.getElementById('add-duration').value = duration;
                document.getElementById('add-error').style.display = 'none';
                updateAddPreview();
                document.getElementById('add-modal').classList.add('active');

                // Load existing pomodoros for conflict checking
                existingPomodoros = existingPomos;
            } catch (e) {
                console.error('Error finding slot:', e);
                // Fall back to opening modal with default time
                showAddModalForDate(dayStr);
            }
        }

        let weekTypeChart = null;

        function renderWeeklySummary(pomodoros) {
            // Update total counts
            const totalPomos = pomodoros.length;
            const totalMinutes = pomodoros.reduce((sum, p) => sum + (p.duration_minutes || 0), 0);
            document.getElementById('week-pomo-count').textContent = totalPomos;
            document.getElementById('week-minutes-count').textContent = totalMinutes;

            // Count by type
            const byType = {};
            pomodoros.forEach(p => {
                byType[p.type] = (byType[p.type] || 0) + 1;
            });

            // Sort by count descending
            const sorted = Object.entries(byType).sort((a, b) => b[1] - a[1]);

            if (sorted.length === 0) {
                // Clear chart if exists
                if (weekTypeChart) {
                    weekTypeChart.destroy();
                    weekTypeChart = null;
                }
                return;
            }

            // Render pie chart
            const typeLabels = sorted.map(([type]) => type);
            const typeData = sorted.map(([, count]) => count);
            const typeColors = sorted.map(([type]) => TYPE_COLORS[type] || '#6b7280');

            if (weekTypeChart) weekTypeChart.destroy();

            // Calculate total for percentage calculations
            const total = typeData.reduce((a, b) => a + b, 0);

            weekTypeChart = new Chart(document.getElementById('week-type-chart'), {
                type: 'pie',
                data: {
                    labels: typeLabels,
                    datasets: [{
                        data: typeData,
                        backgroundColor: typeColors,
                        borderWidth: 2,
                        borderColor: 'var(--bg-secondary)',
                        datalabels: {
                            color: (ctx) => typeColors[ctx.dataIndex] || '#fff',
                            font: {
                                weight: 'bold',
                                size: 11
                            },
                            formatter: (value, ctx) => `${ctx.chart.data.labels[ctx.dataIndex]}: ${value}`,
                            anchor: 'end',
                            align: 'end',
                            offset: 8,
                            textAlign: 'center'
                        }
                    }]
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 50
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const label = ctx.label || '';
                                    const value = ctx.raw;
                                    const percentage = Math.round((value / total) * 100);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Audio element for tick sound (60 Minutes recording)
        let tickAudio = null;

        function initTickAudio() {
            if (!tickAudio) {
                tickAudio = new Audio('/static/tick.mp3');
                tickAudio.loop = true;
            }
        }

        function updateTickVolume() {
            if (tickAudio) {
                const vol = Math.pow((settings.tick_volume ?? 50) / 100, 2);
                tickAudio.volume = vol;
            }
        }

        function startTickSound() {
            if (!settings.tick_sound_enabled) return;
            initTickAudio();
            updateTickVolume();
            tickAudio.currentTime = 0;
            tickAudio.play().catch(e => console.log('Audio play failed:', e));
        }

        function stopTickSound() {
            if (tickAudio) {
                tickAudio.pause();
                tickAudio.currentTime = 0;
            }
        }

        // Report state
        let currentPeriod = 'week';
        let currentDate = new Date().toISOString().split('T')[0];
        let typeChart = null;
        let dailyChart = null;

        // Navigation
        document.querySelectorAll('nav button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.view + '-view').classList.add('active');
                if (btn.dataset.view === 'timer') loadWeeklyOverview();
                if (btn.dataset.view === 'history') loadHistory();
                if (btn.dataset.view === 'reports') loadReport();
            });
        });

        // Timer functions
        const circumference = 2 * Math.PI * 120;
        const maxDragSeconds = 25 * 60; // 25 minutes max (standard pomodoro)

        // Drag utility functions for slidable timer
        function getTimerCenter() {
            const timerRing = document.querySelector('.timer-ring');
            const rect = timerRing.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function getAngleFromPoint(x, y) {
            const center = getTimerCenter();
            // atan2 returns angle from positive x-axis, we want 12 o'clock as 0
            // Add PI/2 to rotate so 12 o'clock is 0
            let angle = Math.atan2(y - center.y, x - center.x) + Math.PI / 2;
            // Normalize to 0 to 2*PI
            if (angle < 0) angle += 2 * Math.PI;
            return angle;
        }

        function updateTimerDisplay() {
            const mins = Math.floor(remainingSeconds / 60);
            const secs = remainingSeconds % 60;
            document.getElementById('timer-time').textContent =
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;

            // Band shows remaining time as fraction of maxDragSeconds (25 min)
            // The stroke has round caps that extend 4px beyond the stroke endpoints
            // We offset the start so the start cap begins just right of 12 o'clock
            const strokeCapSize = 4; // half of stroke-width (8)
            const gapHalf = 1; // half the gap at 12 o'clock

            // Start offset: push start cap to the right of 12 o'clock
            const startOffset = strokeCapSize + gapHalf;
            // End compensation: pull end cap back to align with ticks
            const endCompensation = strokeCapSize + gapHalf;

            const fraction = remainingSeconds / maxDragSeconds;
            // Subtract total offset from both ends
            let visibleLength = circumference * fraction - (startOffset + endCompensation);

            const timerProgress = document.getElementById('timer-progress');
            const endCap = document.getElementById('timer-end-cap');
            if (remainingSeconds <= 0 || visibleLength <= 0) {
                // Hide band completely when timer is at zero
                timerProgress.style.strokeDasharray = `0 ${circumference}`;
                timerProgress.style.strokeDashoffset = '0';
                endCap.style.display = 'none';
            } else {
                // Extend band to center of round cap (full diameter, not just radius)
                const bandLength = visibleLength + strokeCapSize * 2;
                timerProgress.style.strokeDasharray = `${bandLength} ${circumference}`;
                timerProgress.style.strokeDashoffset = startOffset;

                // Position the rounded end cap at the TIME position (not the extended band end)
                // In SVG coordinates (before CSS -90deg rotation), stroke starts at 3 o'clock (angle 0)
                const endPosition = startOffset + visibleLength;
                const endAngle = (endPosition / circumference) * 2 * Math.PI;
                const capX = 140 + 120 * Math.cos(endAngle);
                const capY = 140 + 120 * Math.sin(endAngle);
                endCap.setAttribute('cx', capX);
                endCap.setAttribute('cy', capY);
                endCap.style.display = '';
            }
        }

        function startTimer() {
            timerState = 'running';
            isBreak = false;
            // Use dragged value if set, otherwise use preset
            if (remainingSeconds <= 0) {
                remainingSeconds = getSelectedDuration() * 60;
            }
            totalSeconds = remainingSeconds;
            document.getElementById('timer-status').textContent = 'Focus';
            document.getElementById('timer-progress').classList.remove('break');
            document.getElementById('timer-end-cap').classList.remove('break');
            document.getElementById('btn-start').style.display = 'none';
            document.getElementById('btn-pause').style.display = 'inline-block';
            document.getElementById('btn-stop').style.display = 'inline-block';
            document.getElementById('btn-discard').style.display = 'inline-block';

            timerInterval = setInterval(() => {
                if (remainingSeconds > 0) {
                    remainingSeconds--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    stopTickSound();
                    timerComplete();
                }
            }, 1000);
            startTickSound();
            updateTimerDisplay();
        }

        function getBreakDuration() {
            // Use long break every N pomodoros, unless always_use_short_break is set
            if (settings.always_use_short_break) {
                return settings.short_break_minutes;
            }
            if (pomodorosCompleted > 0 && pomodorosCompleted % settings.pomodoros_until_long_break === 0) {
                return settings.long_break_minutes;
            }
            return settings.short_break_minutes;
        }

        function isLongBreak() {
            if (settings.always_use_short_break) return false;
            return pomodorosCompleted > 0 && pomodorosCompleted % settings.pomodoros_until_long_break === 0;
        }

        function updateBreakInfo() {
            const breakProgressEl = document.getElementById('break-progress');
            const breakProgressBar = document.getElementById('break-progress-bar');
            const breakInfoEl = document.getElementById('break-info');

            // Hide everything if always using short breaks
            if (settings.always_use_short_break) {
                breakInfoEl.style.display = 'none';
                return;
            }

            breakInfoEl.style.display = '';
            const total = settings.pomodoros_until_long_break;
            const currentPosition = pomodorosCompleted % total;

            // Build clickable progress bar segments
            let barHtml = '';
            for (let i = 0; i < total; i++) {
                const isCurrent = i === currentPosition;
                const isFilled = i < currentPosition;
                const className = isCurrent ? 'segment current' : (isFilled ? 'segment filled' : 'segment');
                barHtml += `<div class="${className}" data-position="${i}"></div>`;
            }
            breakProgressBar.innerHTML = barHtml;

            // Add click handlers to segments
            breakProgressBar.querySelectorAll('.segment').forEach(seg => {
                seg.addEventListener('click', () => {
                    const position = parseInt(seg.dataset.position);
                    // Set pomodorosCompleted to match this position in the cycle
                    const cycleBase = Math.floor(pomodorosCompleted / total) * total;
                    pomodorosCompleted = cycleBase + position;
                    updateBreakInfo();
                    updateBreakButtonStyles();
                });
            });

            // Show text status - determined by position
            const isLastPomodoro = currentPosition === total - 1;
            if (isLastPomodoro) {
                breakProgressEl.textContent = 'Long break next';
            } else {
                const remaining = total - currentPosition;
                breakProgressEl.textContent = `${remaining} until long break`;
            }
        }

        function startBreak(manualDuration = null) {
            timerState = 'running';
            isBreak = true;
            const breakMinutes = manualDuration || getBreakDuration();
            const isLong = isLongBreak();
            updateBreakButtonStyles();
            totalSeconds = breakMinutes * 60;
            remainingSeconds = totalSeconds;
            document.getElementById('timer-status').textContent = isLong ? 'Long Break' : 'Break';
            document.getElementById('timer-progress').classList.add('break');
            document.getElementById('timer-end-cap').classList.add('break');
            document.getElementById('btn-start').style.display = 'none';
            document.getElementById('btn-pause').style.display = 'inline-block';
            document.getElementById('btn-stop').style.display = 'inline-block';
            document.getElementById('btn-discard').style.display = 'none';

            timerInterval = setInterval(() => {
                if (remainingSeconds > 0) {
                    remainingSeconds--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    stopTickSound();
                    breakComplete();
                }
            }, 1000);
            // Optionally play tick sound during breaks
            if (settings.tick_sound_during_breaks) {
                startTickSound();
            }
            updateTimerDisplay();
        }

        function pauseTimer() {
            timerState = 'paused';
            clearInterval(timerInterval);
            stopTickSound();
            const breakStatus = isLongBreak() ? 'Long Break Paused' : 'Break Paused';
            document.getElementById('timer-status').textContent = isBreak ? breakStatus : 'Paused';
            document.getElementById('btn-pause').style.display = 'none';
            document.getElementById('btn-resume').style.display = 'inline-block';
        }

        function resumeTimer() {
            timerState = 'running';
            const breakStatus = isLongBreak() ? 'Long Break' : 'Break';
            document.getElementById('timer-status').textContent = isBreak ? breakStatus : 'Focus';
            document.getElementById('btn-resume').style.display = 'none';
            document.getElementById('btn-pause').style.display = 'inline-block';

            timerInterval = setInterval(() => {
                if (remainingSeconds > 0) {
                    remainingSeconds--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    stopTickSound();
                    if (isBreak) {
                        breakComplete();
                    } else {
                        timerComplete();
                    }
                }
            }, 1000);
            if (!isBreak || settings.tick_sound_during_breaks) {
                startTickSound();
            }
        }

        async function stopTimer() {
            clearInterval(timerInterval);
            stopTickSound();
            if (isBreak) {
                // Just reset if stopping during a break
                resetTimer();
            } else {
                // Auto-save with the inline form values
                const saved = await savePomodoro();
                if (saved) {
                    resetTimer();
                }
            }
        }

        async function timerComplete() {
            // Store last pomodoro details for auto-start
            lastPomodoro = {
                type: document.getElementById('timer-pomo-type').value,
                name: document.getElementById('timer-pomo-name').value.trim(),
                notes: document.getElementById('timer-pomo-notes').value.trim() || null
            };

            // Play bell sound
            if (settings.bell_at_pomodoro_end) {
                playBellSound();
            }

            // Increment pomodoro count for long break logic
            pomodorosCompleted++;
            updateBreakInfo();

            // Determine break type for notification
            const breakType = isLongBreak() ? 'long break' : 'break';

            // Play notification
            if (Notification.permission === 'granted') {
                new Notification('Pomodoro Complete!', { body: `Great work! Time for a ${breakType}.` });
            }
            // Auto-save with the inline form values
            await savePomodoro();
            sessionCount++;
            // Start break automatically
            startBreak();
        }

        function breakComplete() {
            // Play bell sound
            if (settings.bell_at_break_end) {
                playBellSound();
            }

            // Play notification
            if (Notification.permission === 'granted') {
                new Notification('Break Complete!', { body: settings.auto_start_after_break ? 'Starting next pomodoro...' : 'Ready for the next pomodoro?' });
            }

            if (settings.auto_start_after_break && lastPomodoro.type) {
                // Restore last pomodoro values
                document.getElementById('timer-pomo-type').value = lastPomodoro.type;
                document.getElementById('timer-pomo-name').value = lastPomodoro.name || '';
                document.getElementById('timer-pomo-notes').value = lastPomodoro.notes || '';
                // Auto-start next pomodoro
                startTimer();
            } else {
                resetTimer();
            }
        }

        function resetTimer() {
            timerState = 'idle';
            isBreak = false;
            remainingSeconds = getSelectedDuration() * 60;
            totalSeconds = remainingSeconds;
            document.getElementById('timer-status').textContent = 'Ready';
            document.getElementById('timer-progress').classList.remove('break');
            document.getElementById('timer-end-cap').classList.remove('break');
            document.getElementById('btn-start').style.display = 'inline-block';
            document.getElementById('btn-pause').style.display = 'none';
            document.getElementById('btn-resume').style.display = 'none';
            document.getElementById('btn-stop').style.display = 'none';
            document.getElementById('btn-discard').style.display = 'none';
            updateTimerDisplay();
            updateBreakInfo();
        }

        async function savePomodoro() {
            const name = document.getElementById('timer-pomo-name').value.trim();

            await fetch('/api/pomodoros', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name,
                    type: document.getElementById('timer-pomo-type').value,
                    duration_minutes: Math.round(totalSeconds / 60),
                    notes: document.getElementById('timer-pomo-notes').value.trim() || null
                })
            });

            // Keep fields visible during break (stored in lastPomodoro for auto-start)
            loadWeeklyOverview(); // Refresh weekly view
            return true;
        }

        function clearTimerFields() {
            document.getElementById('timer-pomo-name').value = '';
            document.getElementById('timer-pomo-notes').value = '';
        }

        document.getElementById('btn-start').addEventListener('click', startTimer);
        document.getElementById('btn-pause').addEventListener('click', pauseTimer);
        document.getElementById('btn-resume').addEventListener('click', resumeTimer);
        document.getElementById('btn-stop').addEventListener('click', stopTimer);
        document.getElementById('btn-discard').addEventListener('click', discardTimer);

        function discardTimer() {
            clearInterval(timerInterval);
            stopTickSound();
            resetTimer();
        }

        // Break preset buttons - set pomodoro position
        document.getElementById('btn-short-break').addEventListener('click', () => {
            const total = settings.pomodoros_until_long_break;
            const cycleBase = Math.floor(pomodorosCompleted / total) * total;
            pomodorosCompleted = cycleBase; // Set to first pomodoro (position 0)
            updateBreakButtonStyles();
            updateBreakInfo();
        });
        document.getElementById('btn-long-break').addEventListener('click', () => {
            const total = settings.pomodoros_until_long_break;
            const cycleBase = Math.floor(pomodorosCompleted / total) * total;
            pomodorosCompleted = cycleBase + total - 1; // Set to last pomodoro
            updateBreakButtonStyles();
            updateBreakInfo();
        });

        function updateBreakButtonStyles() {
            const shortBtn = document.getElementById('btn-short-break');
            const longBtn = document.getElementById('btn-long-break');
            const total = settings.pomodoros_until_long_break;
            const currentPosition = pomodorosCompleted % total;
            const isLastPomodoro = currentPosition === total - 1;

            // Auto-select break button based on position
            shortBtn.classList.toggle('active', !isLastPomodoro);
            longBtn.classList.toggle('active', isLastPomodoro);

            // Update button text with current break durations
            shortBtn.textContent = settings.short_break_minutes;
            longBtn.textContent = settings.long_break_minutes;
        }

        // Drag handlers for slidable timer
        function handleTimerDragStart(e) {
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;

            // Set time based on click position immediately, with snap
            const currentAngle = getAngleFromPoint(e.clientX, e.clientY);
            let newSeconds = (currentAngle / (2 * Math.PI)) * maxDragSeconds;
            newSeconds = Math.max(0, Math.min(maxDragSeconds, newSeconds));

            // Apply snap interval during drag
            const snapInterval = settings.timer_snap_interval || 60;
            if (snapInterval > 1) {
                newSeconds = Math.round(newSeconds / snapInterval) * snapInterval;
            } else {
                newSeconds = Math.round(newSeconds);
            }

            remainingSeconds = newSeconds;
            if (timerState === 'idle') {
                totalSeconds = remainingSeconds;
            }
            updateTimerDisplay();

            // Set pointer capture for reliable tracking
            if (e.target.setPointerCapture) {
                e.target.setPointerCapture(e.pointerId);
            }

            // Change cursor to grabbing
            document.body.style.cursor = 'grabbing';
        }

        function handleTimerDragMove(e) {
            if (!isDragging) return;

            // Get the current angle from 12 o'clock (0 to 2*PI, clockwise)
            const currentAngle = getAngleFromPoint(e.clientX, e.clientY);

            // Direct mapping: angle position = time remaining
            // Clockwise from 12 o'clock = more time
            // Full circle (2*PI) = maxDragSeconds (25 minutes)
            let newSeconds = (currentAngle / (2 * Math.PI)) * maxDragSeconds;

            // Clamp to valid range
            newSeconds = Math.max(0, Math.min(maxDragSeconds, newSeconds));

            // Apply snap interval during drag
            const snapInterval = settings.timer_snap_interval || 60;
            if (snapInterval > 1) {
                newSeconds = Math.round(newSeconds / snapInterval) * snapInterval;
            } else {
                newSeconds = Math.round(newSeconds);
            }

            remainingSeconds = newSeconds;

            // Update totalSeconds if timer is idle (adjusting preset)
            if (timerState === 'idle') {
                totalSeconds = remainingSeconds;
            }

            // Update display in real-time
            updateTimerDisplay();

            // If dragged to zero while running, trigger completion
            if (remainingSeconds <= 0 && timerState === 'running') {
                isDragging = false;
                document.body.style.cursor = '';
                clearInterval(timerInterval);
                stopTickSound();
                if (isBreak) {
                    breakComplete();
                } else {
                    timerComplete();
                }
            }
        }

        function handleTimerDragEnd(e) {
            if (!isDragging) return;
            isDragging = false;

            // Snap to configured interval
            const snapInterval = settings.timer_snap_interval || 60;
            if (snapInterval > 1) {
                remainingSeconds = Math.round(remainingSeconds / snapInterval) * snapInterval;
            }
            if (timerState === 'idle') {
                totalSeconds = remainingSeconds;
            }
            updateTimerDisplay();

            // Release pointer capture
            if (e.target.releasePointerCapture) {
                e.target.releasePointerCapture(e.pointerId);
            }

            // Reset cursor
            document.body.style.cursor = '';
        }

        // Attach drag event listeners to timer display area
        const timerDisplay = document.querySelector('.timer-display');
        if (timerDisplay) {
            timerDisplay.addEventListener('pointerdown', handleTimerDragStart);
            document.addEventListener('pointermove', handleTimerDragMove);
            document.addEventListener('pointerup', handleTimerDragEnd);
            document.addEventListener('pointercancel', handleTimerDragEnd);
        }

        // Duration preset buttons
        function updatePresetButtons() {
            document.querySelectorAll('#duration-presets button').forEach(btn => {
                const preset = parseInt(btn.dataset.preset);
                const minutes = settings[`timer_preset_${preset}`];
                btn.textContent = minutes;
                if (preset === selectedPreset) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateNotesFieldVisibility() {
            const notesField = document.getElementById('timer-pomo-notes');
            if (notesField) {
                notesField.style.display = settings.show_notes_field ? 'block' : 'none';
            }
        }

        function updateTimerTicksVisibility() {
            const timerTicks = document.getElementById('timer-ticks');
            if (timerTicks) {
                timerTicks.style.display = settings.show_timer_ticks ? 'block' : 'none';
            }
        }

        function getSelectedDuration() {
            return settings[`timer_preset_${selectedPreset}`];
        }

        document.querySelectorAll('#duration-presets button').forEach(btn => {
            btn.addEventListener('click', () => {
                if (timerState !== 'idle') return; // Don't change duration while timer is running
                document.querySelectorAll('#duration-presets button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedPreset = parseInt(btn.dataset.preset);
                const minutes = getSelectedDuration();
                remainingSeconds = minutes * 60;
                totalSeconds = remainingSeconds;
                updateTimerDisplay();
            });
        });

        // History
        async function loadHistory() {
            const list = document.getElementById('history-list');
            try {
                const res = await fetch('/api/pomodoros');
                const pomodoros = await res.json();

                if (!Array.isArray(pomodoros) || pomodoros.length === 0) {
                    list.innerHTML = '<div class="empty">No pomodoros yet. Start your first timer!</div>';
                    return;
                }

                // Group by date
                const grouped = {};
                pomodoros.forEach(p => {
                    const date = formatDateWithDay(p.start_time);
                    if (!grouped[date]) grouped[date] = [];
                    grouped[date].push(p);
                });

                let html = '';
                for (const [date, items] of Object.entries(grouped)) {
                    // Sort items within this day by start time (morning to evening)
                    items.sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
                    html += `<h3>${date}</h3>`;
                    items.forEach(p => {
                        const color = TYPE_COLORS[p.type] || '#6b7280';
                        const time = new Date(p.start_time).toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                        const safeId = escapeHtml(p.id);
                        html += `
                            <div class="pomodoro-item" data-id="${safeId}">
                                <div>
                                    <span class="pomodoro-name">${escapeHtml(p.name)}</span>
                                    <span class="pomodoro-type" style="background:${color}20;color:${color}">${escapeHtml(p.type)}</span>
                                    <div class="pomodoro-meta">${time} - ${p.duration_minutes} min</div>
                                </div>
                                <div class="pomodoro-actions">
                                    <button class="delete-btn" title="Delete">&#10005;</button>
                                </div>
                            </div>
                        `;
                    });
                }
                list.innerHTML = html;

                // Attach event listeners - click item to edit, delete button to delete
                list.querySelectorAll('.pomodoro-item').forEach(item => {
                    const id = item.dataset.id;
                    // Click anywhere on item to edit (with highlight)
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.pomodoro-item.highlighted').forEach(el => el.classList.remove('highlighted'));
                        item.classList.add('highlighted');
                        showEditModal(id);
                    });
                    // Delete button stops propagation so it doesn't trigger edit
                    item.querySelector('.delete-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        deletePomodoro(id);
                    });
                });
            } catch (e) {
                console.error('Error loading history:', e);
                list.innerHTML = '<div class="empty">Error loading history. Please refresh.</div>';
            }
        }

        // Navigate to a specific pomodoro in History tab and highlight it
        async function navigateToPomodoro(id) {
            // Switch to History tab
            document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelector('nav button[data-view="history"]').classList.add('active');
            document.getElementById('history-view').classList.add('active');

            // Load history and wait for it to complete
            await loadHistory();

            // Find and highlight the pomodoro
            const item = document.querySelector(`.pomodoro-item[data-id="${CSS.escape(id)}"]`);
            if (item) {
                // Remove any existing highlights
                document.querySelectorAll('.pomodoro-item.highlighted').forEach(el => el.classList.remove('highlighted'));

                // Scroll to the item
                item.scrollIntoView({ behavior: 'smooth', block: 'center' });

                // Add highlight (stays until another item is clicked)
                item.classList.add('highlighted');
            }
        }

        async function deletePomodoro(id) {
            await fetch(`/api/pomodoros/${id}`, { method: 'DELETE' });
            loadHistory();
        }

        let existingPomodoros = []; // Cache for conflict checking

        // Get default start time based on working hours
        function getDefaultStartTime(now) {
            const workStart = settings.working_hours_start || '08:00';
            const workEnd = settings.working_hours_end || '17:00';

            const [startHour, startMin] = workStart.split(':').map(Number);
            const [endHour, endMin] = workEnd.split(':').map(Number);

            const currentHour = now.getHours();
            const currentMin = now.getMinutes();
            const currentTimeMinutes = currentHour * 60 + currentMin;
            const workStartMinutes = startHour * 60 + startMin;
            const workEndMinutes = endHour * 60 + endMin;

            if (currentTimeMinutes < workStartMinutes) {
                // Before working hours: use working hours start
                return workStart;
            } else if (currentTimeMinutes >= workEndMinutes) {
                // After working hours: use 12:00 noon
                return '12:00';
            } else {
                // During working hours: use current time snapped to half hour
                return formatTimeSnapped(now);
            }
        }

        function showAddModal() {
            // Use local date and time (not UTC) to avoid timezone issues
            const now = new Date();
            // Set date using Flatpickr API
            if (addDatePicker) {
                addDatePicker.setDate(now, true);
            }
            // Set time using Flatpickr API
            if (addTimePicker) {
                addTimePicker.setDate(getDefaultStartTime(now), true);
            }
            document.getElementById('add-count').value = '1';
            document.getElementById('add-error').style.display = 'none';
            updateAddPreview();
            document.getElementById('add-modal').classList.add('active');

            // Load existing pomodoros for conflict checking
            fetch('/api/pomodoros').then(r => r.json()).then(p => existingPomodoros = p);
        }

        function showAddModalForDate(dateStr) {
            // Open the add modal with the specified date pre-filled
            const workStart = settings.working_hours_start || '08:00';
            const date = new Date(dateStr + 'T' + workStart + ':00');
            // Set date using Flatpickr API
            if (addDatePicker) {
                addDatePicker.setDate(date, true);
            }
            // Set time using Flatpickr API
            if (addTimePicker) {
                addTimePicker.setDate(workStart, true);
            }
            document.getElementById('add-count').value = '1';
            document.getElementById('add-duration').value = settings[`timer_preset_${selectedPreset}`] || 25;
            document.getElementById('add-error').style.display = 'none';
            updateAddPreview();
            document.getElementById('add-modal').classList.add('active');

            // Load existing pomodoros for conflict checking
            fetch('/api/pomodoros').then(r => r.json()).then(p => existingPomodoros = p);
        }

        function hideAddModal() {
            document.getElementById('add-modal').classList.remove('active');
        }

        // Align time to nearest half-hour boundary
        function alignToHalfHour(date) {
            const aligned = new Date(date);
            const minutes = aligned.getMinutes();
            if (minutes < 15) {
                aligned.setMinutes(0, 0, 0);
            } else if (minutes < 45) {
                aligned.setMinutes(30, 0, 0);
            } else {
                aligned.setMinutes(0, 0, 0);
                aligned.setHours(aligned.getHours() + 1);
            }
            return aligned;
        }

        // Find next available slot that doesn't conflict
        function findNextAvailableSlot(startTime, duration, existingSlots) {
            let candidate = alignToHalfHour(startTime);
            const maxAttempts = 48; // Max 24 hours of searching

            for (let i = 0; i < maxAttempts; i++) {
                const candidateEnd = new Date(candidate.getTime() + duration * 60000);
                let hasConflict = false;

                // Check against existing pomodoros
                for (const p of existingPomodoros) {
                    const pStart = new Date(p.start_time);
                    const pEnd = new Date(p.end_time);
                    if (candidate < pEnd && candidateEnd > pStart) {
                        hasConflict = true;
                        break;
                    }
                }

                // Check against slots we're about to add
                for (const slot of existingSlots) {
                    if (candidate < slot.end && candidateEnd > slot.start) {
                        hasConflict = true;
                        break;
                    }
                }

                if (!hasConflict) {
                    return candidate;
                }

                // Move to next half-hour
                candidate = new Date(candidate.getTime() + 30 * 60000);
            }

            return null; // No slot found
        }

        function updateAddPreview() {
            const date = document.getElementById('add-date').value;
            const time = document.getElementById('add-time').value;
            const duration = parseInt(document.getElementById('add-duration').value) || 25;
            const count = parseInt(document.getElementById('add-count').value) || 1;

            if (!date || !time) {
                document.getElementById('add-preview').textContent = '';
                return;
            }

            const startTime = new Date(`${date}T${time}`);
            const slots = [];
            let currentStart = startTime;

            for (let i = 0; i < count; i++) {
                const slot = findNextAvailableSlot(currentStart, duration, slots);
                if (!slot) {
                    document.getElementById('add-preview').textContent = `Can only fit ${i} entries without conflicts`;
                    return;
                }
                slots.push({
                    start: slot,
                    end: new Date(slot.getTime() + duration * 60000)
                });
                currentStart = new Date(slot.getTime() + duration * 60000);
            }

            if (count === 1) {
                const s = slots[0];
                document.getElementById('add-preview').textContent =
                    `Will create: ${s.start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${s.end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            } else {
                const first = slots[0];
                const last = slots[slots.length - 1];
                document.getElementById('add-preview').textContent =
                    `Will create ${count} entries: ${first.start.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} - ${last.end.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
            }
        }

        // Add event listeners for preview updates
        document.addEventListener('DOMContentLoaded', () => {
            ['add-date', 'add-duration', 'add-count'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', updateAddPreview);
                    el.addEventListener('change', updateAddPreview);
                }
            });
            // Time picker onChange is handled by Flatpickr in initTimePickers()

            // Save edit modal on Enter key (except in textarea)
            document.getElementById('edit-modal').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    saveEditedPomodoro();
                }
            });
        });

        async function addManualPomodoro() {
            try {
                const name = document.getElementById('add-name').value.trim();
                const type = document.getElementById('add-type').value;
                const date = document.getElementById('add-date').value;
                const time = document.getElementById('add-time').value;
                const duration = parseInt(document.getElementById('add-duration').value);
                const count = parseInt(document.getElementById('add-count').value) || 1;

                if (!date || !time) {
                    document.getElementById('add-error').textContent = 'Please select a date and time.';
                    document.getElementById('add-error').style.display = 'block';
                    return;
                }

                const startTime = new Date(`${date}T${time}`);
                const slots = [];
                let currentStart = startTime;

                // Calculate all slots first
                for (let i = 0; i < count; i++) {
                    const slot = findNextAvailableSlot(currentStart, duration, slots);
                    if (!slot) {
                        document.getElementById('add-error').textContent = `Could only find ${i} available slots. Reduce count or change start time.`;
                        document.getElementById('add-error').style.display = 'block';
                        return;
                    }
                    slots.push({
                        start: slot,
                        end: new Date(slot.getTime() + duration * 60000)
                    });
                    currentStart = new Date(slot.getTime() + duration * 60000);
                }

                // Create all pomodoros
                for (const slot of slots) {
                    await fetch('/api/pomodoros/manual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name,
                            type,
                            start_time: slot.start.toISOString(),
                            end_time: slot.end.toISOString(),
                            duration_minutes: duration
                        })
                    });
                }

                hideAddModal();
                document.getElementById('add-name').value = '';
                document.getElementById('add-count').value = '1';
                document.getElementById('add-error').style.display = 'none';
                await loadHistory();
                loadWeeklyOverview();
            } catch (e) {
                console.error('Error adding manual pomodoro:', e);
                document.getElementById('add-error').textContent = 'Error adding entry: ' + e.message;
                document.getElementById('add-error').style.display = 'block';
            }
        }

        // Edit pomodoro functions
        let allPomodoros = []; // Cache for lookup

        // Snap minutes to nearest 30-minute interval
        function snapTo30Minutes(minutes) {
            return Math.round(minutes / 30) * 30;
        }

        // Format time as HH:MM with 30-minute snapping
        function formatTimeSnapped(date) {
            const snappedMinutes = snapTo30Minutes(date.getMinutes());
            const hours = snappedMinutes >= 60 ? date.getHours() + 1 : date.getHours();
            return `${String(hours % 24).padStart(2, '0')}:${String(snappedMinutes % 60).padStart(2, '0')}`;
        }

        async function showEditModal(id) {
            // Fetch all pomodoros to find the one to edit
            const res = await fetch('/api/pomodoros');
            allPomodoros = await res.json();
            const pomo = allPomodoros.find(p => p.id === id);
            if (!pomo) {
                alert('Pomodoro not found');
                return;
            }

            // Populate the edit form
            document.getElementById('edit-id').value = pomo.id;
            document.getElementById('edit-name').value = pomo.name;
            document.getElementById('edit-type').value = pomo.type;
            document.getElementById('edit-notes').value = pomo.notes || '';
            document.getElementById('edit-duration').value = pomo.duration_minutes;

            // Use the entry's date and time
            const startDate = new Date(pomo.start_time);
            // Set date using Flatpickr API
            if (editDatePicker) {
                editDatePicker.setDate(startDate, true);
            }
            // Set time using Flatpickr API
            if (editTimePicker) {
                editTimePicker.setDate(formatTimeSnapped(startDate), true);
            }

            document.getElementById('edit-modal').classList.add('active');
        }

        function hideEditModal() {
            document.getElementById('edit-modal').classList.remove('active');
        }

        async function saveEditedPomodoro() {
            const id = document.getElementById('edit-id').value;
            const name = document.getElementById('edit-name').value.trim();

            const dateStr = document.getElementById('edit-date').value;
            const time = document.getElementById('edit-time').value;
            const duration = parseInt(document.getElementById('edit-duration').value);

            // HTML date input returns YYYY-MM-DD format
            const startTime = new Date(`${dateStr}T${time}`);
            const endTime = new Date(startTime.getTime() + duration * 60000);

            await fetch(`/api/pomodoros/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name,
                    type: document.getElementById('edit-type').value,
                    start_time: startTime.toISOString(),
                    end_time: endTime.toISOString(),
                    duration_minutes: duration,
                    notes: document.getElementById('edit-notes').value.trim() || null
                })
            });

            hideEditModal();
            loadHistory();
            loadWeeklyOverview();
        }

        // Reports
        document.querySelectorAll('.period-selector button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.period-selector button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPeriod = btn.dataset.period;
                loadReport();
            });
        });

        function navigatePeriod(dir) {
            const d = new Date(currentDate);
            if (currentPeriod === 'day') d.setDate(d.getDate() + dir);
            else if (currentPeriod === 'week') d.setDate(d.getDate() + dir * 7);
            else d.setMonth(d.getMonth() + dir);
            currentDate = d.toISOString().split('T')[0];
            loadReport();
        }

        function goToCurrentPeriod() {
            // Use local date to avoid timezone offset issues
            currentDate = new Date().toLocaleDateString('en-CA');
            loadReport();
        }

        async function loadReport() {
            const dateRange = getDateRange(currentPeriod, currentDate);
            const res = await fetch(`/api/reports/${currentPeriod}?start_date=${encodeURIComponent(dateRange.start)}&end_date=${encodeURIComponent(dateRange.end)}`);
            const data = await res.json();

            // Update summary
            document.getElementById('report-count').textContent = data.total_pomodoros;
            const hours = Math.floor(data.total_minutes / 60);
            const mins = data.total_minutes % 60;
            document.getElementById('report-time').textContent = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
            document.getElementById('report-avg').textContent = data.total_pomodoros > 0
                ? Math.round(data.total_minutes / data.total_pomodoros) + 'm' : '0m';

            // Update period label
            const d = new Date(currentDate);
            let label = '';
            if (currentPeriod === 'day') {
                label = d.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' });
            } else if (currentPeriod === 'week') {
                const start = new Date(d);
                start.setDate(d.getDate() - d.getDay());
                const end = new Date(start);
                end.setDate(start.getDate() + 6);
                label = `${start.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })} - ${end.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}`;
            } else {
                label = d.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
            }
            document.getElementById('period-label').textContent = label;

            // Type chart
            const typeLabels = Object.keys(data.by_type).filter(k => data.by_type[k] > 0);
            const typeData = typeLabels.map(k => data.by_type[k]);
            const typeColors = typeLabels.map(k => TYPE_COLORS[k] || '#6b7280');

            if (typeChart) typeChart.destroy();
            const reportTotal = typeData.reduce((a, b) => a + b, 0);
            typeChart = new Chart(document.getElementById('chart-type'), {
                type: 'pie',
                data: {
                    labels: typeLabels,
                    datasets: [{
                        data: typeData,
                        backgroundColor: typeColors,
                        borderWidth: 2,
                        borderColor: 'var(--bg-secondary)'
                    }]
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 50
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: (ctx) => typeColors[ctx.dataIndex] || '#fff',
                            font: {
                                weight: 'bold',
                                size: 11
                            },
                            formatter: (value, ctx) => {
                                // Show label with minute count
                                return `${ctx.chart.data.labels[ctx.dataIndex]}: ${value}`;
                            },
                            anchor: 'end',
                            align: 'end',
                            offset: 8,
                            textAlign: 'center',
                            clamp: true
                        },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const label = ctx.label || '';
                                    const value = ctx.raw;
                                    const percentage = Math.round((value / reportTotal) * 100);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // Daily chart - stacked by type
            if (dailyChart) dailyChart.destroy();

            // For monthly view, use diagonal labels; for day/week, use stacked labels
            const isMonthly = currentPeriod === 'month';
            const chartLabels = data.daily_totals.map(d => {
                const dt = new Date(d.date + 'T00:00:00');
                const dayName = dt.toLocaleDateString(undefined, { weekday: 'short' });
                const dateStr = formatDate(dt);
                if (isMonthly) {
                    return `${dayName} ${dateStr}`;
                }
                return [dayName, dateStr];
            });

            // Fetch raw pomodoros for this period to build stacked chart
            const pomosRes = await fetch(`/api/pomodoros?start_date=${dateRange.start}&end_date=${dateRange.end}`);
            const pomos = await pomosRes.json();

            // Get all unique types that have data
            const typesInPeriod = [...new Set(pomos.map(p => p.type))];

            // Helper to get first word of a label (for space-constrained display)
            const getFirstWord = (label) => label.split(/[\s\/\-_]+/)[0];

            // Build datasets for each type
            const datasets = typesInPeriod.map(type => {
                const color = TYPE_COLORS[type] || '#6b7280';
                return {
                    label: type,
                    shortLabel: getFirstWord(type),  // First word for limited space
                    data: data.daily_totals.map(d => {
                        // Sum minutes for this type on this day
                        return pomos
                            .filter(p => p.type === type && p.start_time.startsWith(d.date))
                            .reduce((sum, p) => sum + p.duration_minutes, 0);
                    }),
                    backgroundColor: color + 'B3', // Add transparency
                    borderColor: color,
                    borderWidth: 1
                };
            });

            dailyChart = new Chart(document.getElementById('chart-daily'), {
                type: 'bar',
                data: {
                    labels: chartLabels,
                    datasets: datasets
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                // Show full type name in tooltip
                                label: (ctx) => `${ctx.dataset.label}: ${ctx.raw} min`
                            }
                        },
                        datalabels: {
                            display: false
                        },
                        annotation: {
                            annotations: {
                                goalLine: {
                                    type: 'line',
                                    yMin: settings.daily_minutes_goal || 300,
                                    yMax: settings.daily_minutes_goal || 300,
                                    borderColor: '#e94560',
                                    borderWidth: 2,
                                    borderDash: [5, 5],
                                    label: {
                                        display: true,
                                        content: 'Goal',
                                        position: 'end',
                                        backgroundColor: 'transparent',
                                        color: '#e94560',
                                        font: { size: 10 }
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: '#a0a0a0',
                                maxRotation: isMonthly ? 45 : 0,
                                minRotation: isMonthly ? 45 : 0,
                                autoSkip: false,
                                font: {
                                    size: isMonthly ? 9 : 12
                                }
                            },
                            grid: { color: '#1a1a2e' }
                        },
                        y: {
                            stacked: true,
                            ticks: { color: '#a0a0a0' },
                            grid: { color: '#1a1a2e' }
                        }
                    }
                }
            });
        }

        // Helper to get date range for a period
        function getDateRange(period, dateStr) {
            // Parse date string as local time (not UTC) by appending time component
            const refDate = new Date(dateStr + 'T00:00:00');
            let start, end;

            if (period === 'day') {
                start = new Date(refDate);
                start.setHours(0, 0, 0, 0);
                end = new Date(start);
                end.setDate(end.getDate() + 1);
            } else if (period === 'week') {
                start = new Date(refDate);
                start.setDate(refDate.getDate() - refDate.getDay());
                start.setHours(0, 0, 0, 0);
                end = new Date(start);
                end.setDate(start.getDate() + 7);
            } else {
                start = new Date(refDate.getFullYear(), refDate.getMonth(), 1);
                end = new Date(refDate.getFullYear(), refDate.getMonth() + 1, 1);
            }

            return {
                start: start.toISOString(),
                end: end.toISOString()
            };
        }

        // Settings
        async function loadSettings() {
            const res = await fetch('/api/settings');
            settings = await res.json();

            // Pomodoro types (ensure it's an array)
            if (!settings.pomodoro_types || !Array.isArray(settings.pomodoro_types)) {
                settings.pomodoro_types = [];
            }

            // Timer presets (defaults if not set)
            settings.timer_preset_1 = settings.timer_preset_1 ?? 5;
            settings.timer_preset_2 = settings.timer_preset_2 ?? 10;
            settings.timer_preset_3 = settings.timer_preset_3 ?? 15;
            settings.timer_preset_4 = settings.timer_preset_4 ?? 25;

            document.getElementById('preset1-duration').value = settings.timer_preset_1;
            document.getElementById('preset1-value').textContent = settings.timer_preset_1 + ' min';
            document.getElementById('preset2-duration').value = settings.timer_preset_2;
            document.getElementById('preset2-value').textContent = settings.timer_preset_2 + ' min';
            document.getElementById('preset3-duration').value = settings.timer_preset_3;
            document.getElementById('preset3-value').textContent = settings.timer_preset_3 + ' min';
            document.getElementById('preset4-duration').value = settings.timer_preset_4;
            document.getElementById('preset4-value').textContent = settings.timer_preset_4 + ' min';

            // Update preset buttons on timer
            updatePresetButtons();

            // Breaks
            settings.short_break_minutes = settings.short_break_minutes ?? 5;
            settings.long_break_minutes = settings.long_break_minutes ?? 15;
            settings.pomodoros_until_long_break = settings.pomodoros_until_long_break ?? 4;

            document.getElementById('short-break').value = settings.short_break_minutes;
            document.getElementById('short-break-value').textContent = settings.short_break_minutes + ' min';
            document.getElementById('long-break').value = settings.long_break_minutes;
            document.getElementById('long-break-value').textContent = settings.long_break_minutes + ' min';
            document.getElementById('long-break-after').value = settings.pomodoros_until_long_break;
            document.getElementById('long-break-after-value').textContent = settings.pomodoros_until_long_break + ' pomodoros';

            // Always use short break (default to false)
            settings.always_use_short_break = settings.always_use_short_break === true;
            document.getElementById('always-short-break').checked = settings.always_use_short_break;

            // Sound enabled (default to true if not set)
            settings.tick_sound_enabled = settings.tick_sound_enabled !== false;
            document.getElementById('tick-sound-enabled').checked = settings.tick_sound_enabled;

            // Auto-start after break (default to false)
            settings.auto_start_after_break = settings.auto_start_after_break === true;
            document.getElementById('auto-start-after-break').checked = settings.auto_start_after_break;

            // Tick sound during breaks (default to false)
            settings.tick_sound_during_breaks = settings.tick_sound_during_breaks === true;
            document.getElementById('tick-sound-during-breaks').checked = settings.tick_sound_during_breaks;

            // Show notes field (default to false)
            settings.show_notes_field = settings.show_notes_field === true;
            document.getElementById('show-notes-field').checked = settings.show_notes_field;
            updateNotesFieldVisibility();

            // Show timer ticks (default to false)
            settings.show_timer_ticks = settings.show_timer_ticks === true;
            document.getElementById('show-timer-ticks').checked = settings.show_timer_ticks;
            updateTimerTicksVisibility();

            // Timer snap interval (default to 60 seconds)
            settings.timer_snap_interval = settings.timer_snap_interval || 60;
            document.getElementById('timer-snap-interval').value = settings.timer_snap_interval;

            // Working hours (default to 08:00 - 17:00)
            settings.working_hours_start = settings.working_hours_start || '08:00';
            settings.working_hours_end = settings.working_hours_end || '17:00';
            // Values are set in initTimePickers()

            // Bell at pomodoro end (default to true)
            settings.bell_at_pomodoro_end = settings.bell_at_pomodoro_end !== false;
            document.getElementById('bell-at-pomodoro-end').checked = settings.bell_at_pomodoro_end;

            // Bell at break end (default to true)
            settings.bell_at_break_end = settings.bell_at_break_end !== false;
            document.getElementById('bell-at-break-end').checked = settings.bell_at_break_end;

            // Sound volume (default to 50 if not set)
            const tickVolume = settings.tick_volume ?? 50;
            document.getElementById('tick-volume').value = tickVolume;
            document.getElementById('tick-volume-value').textContent = tickVolume + '%';
            settings.tick_volume = tickVolume;

            // Update timer display with selected preset
            remainingSeconds = getSelectedDuration() * 60;
            totalSeconds = remainingSeconds;
            updateTimerDisplay();

            // Timezone (default to browser timezone)
            if (!settings.timezone) {
                settings.timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            }
            document.getElementById('timezone').value = settings.timezone;
            updateClock();

            // Date format (default to US)
            if (!settings.date_format) {
                settings.date_format = 'us';
            }
            document.getElementById('date-format').value = settings.date_format;

            // Clock format (default to auto)
            if (!settings.clock_format) {
                settings.clock_format = 'auto';
            }
            document.getElementById('clock-format').value = settings.clock_format;

            // Period labels (default to auto)
            if (!settings.period_labels) {
                settings.period_labels = 'auto';
            }
            document.getElementById('period-labels').value = settings.period_labels;

            // Daily minutes goal (default to 300 = 12 pomodoros x 25 min)
            if (!settings.daily_minutes_goal) {
                settings.daily_minutes_goal = 300;
            }
            document.getElementById('daily-minutes-goal').value = settings.daily_minutes_goal;

            // Initialize date pickers with locale-aware week start
            initDatePickers();

            // Initialize time pickers
            initTimePickers();

            // Populate type dropdowns and settings list
            populateTypeDropdowns();
            renderTypesList();

            // Update break info display
            updateBreakInfo();
            updateBreakButtonStyles();
        }

        // Timer preset sliders
        [1, 2, 3, 4].forEach(n => {
            document.getElementById(`preset${n}-duration`).addEventListener('input', e => {
                document.getElementById(`preset${n}-value`).textContent = e.target.value + ' min';
                settings[`timer_preset_${n}`] = parseInt(e.target.value);
                updatePresetButtons();
                if (selectedPreset === n && timerState === 'idle') {
                    remainingSeconds = parseInt(e.target.value) * 60;
                    totalSeconds = remainingSeconds;
                    updateTimerDisplay();
                }
            });
            document.getElementById(`preset${n}-duration`).addEventListener('change', e => {
                settings[`timer_preset_${n}`] = parseInt(e.target.value);
                autoSaveSettings();
            });
        });

        // Short break slider
        document.getElementById('short-break').addEventListener('input', e => {
            document.getElementById('short-break-value').textContent = e.target.value + ' min';
            settings.short_break_minutes = parseInt(e.target.value);
        });
        document.getElementById('short-break').addEventListener('change', e => {
            settings.short_break_minutes = parseInt(e.target.value);
            autoSaveSettings();
        });

        // Long break slider
        document.getElementById('long-break').addEventListener('input', e => {
            document.getElementById('long-break-value').textContent = e.target.value + ' min';
            settings.long_break_minutes = parseInt(e.target.value);
        });
        document.getElementById('long-break').addEventListener('change', e => {
            settings.long_break_minutes = parseInt(e.target.value);
            autoSaveSettings();
        });

        // Long break after N pomodoros slider
        document.getElementById('long-break-after').addEventListener('input', e => {
            document.getElementById('long-break-after-value').textContent = e.target.value + ' pomodoros';
            settings.pomodoros_until_long_break = parseInt(e.target.value);
        });
        document.getElementById('long-break-after').addEventListener('change', e => {
            settings.pomodoros_until_long_break = parseInt(e.target.value);
            autoSaveSettings();
        });

        // Always use short break checkbox
        document.getElementById('always-short-break').addEventListener('change', e => {
            settings.always_use_short_break = e.target.checked;
            autoSaveSettings();
        });

        // Tick sound checkbox - auto-save
        document.getElementById('tick-sound-enabled').addEventListener('change', e => {
            settings.tick_sound_enabled = e.target.checked;
            autoSaveSettings();
        });

        // Auto-start after break checkbox - auto-save
        document.getElementById('auto-start-after-break').addEventListener('change', e => {
            settings.auto_start_after_break = e.target.checked;
            autoSaveSettings();
        });

        // Tick sound during breaks checkbox - auto-save
        document.getElementById('tick-sound-during-breaks').addEventListener('change', e => {
            settings.tick_sound_during_breaks = e.target.checked;
            autoSaveSettings();
        });

        // Show notes field checkbox - auto-save
        document.getElementById('show-notes-field').addEventListener('change', e => {
            settings.show_notes_field = e.target.checked;
            updateNotesFieldVisibility();
            autoSaveSettings();
        });

        // Show timer ticks checkbox - auto-save
        document.getElementById('show-timer-ticks').addEventListener('change', e => {
            settings.show_timer_ticks = e.target.checked;
            updateTimerTicksVisibility();
            autoSaveSettings();
        });

        // Timer snap interval - auto-save
        document.getElementById('timer-snap-interval').addEventListener('change', e => {
            settings.timer_snap_interval = parseInt(e.target.value);
            autoSaveSettings();
        });

        // Working hours are handled by Flatpickr onChange in initTimePickers()

        // Bell at pomodoro end checkbox - auto-save
        document.getElementById('bell-at-pomodoro-end').addEventListener('change', e => {
            settings.bell_at_pomodoro_end = e.target.checked;
            autoSaveSettings();
        });

        // Bell at break end checkbox - auto-save
        document.getElementById('bell-at-break-end').addEventListener('change', e => {
            settings.bell_at_break_end = e.target.checked;
            autoSaveSettings();
        });

        // Tick volume slider - auto-save
        document.getElementById('tick-volume').addEventListener('input', e => {
            document.getElementById('tick-volume-value').textContent = e.target.value + '%';
            settings.tick_volume = parseInt(e.target.value);
            updateTickVolume();
        });
        document.getElementById('tick-volume').addEventListener('change', e => {
            settings.tick_volume = parseInt(e.target.value);
            autoSaveSettings();
        });

        // Timezone dropdown - auto-save
        document.getElementById('timezone').addEventListener('change', e => {
            settings.timezone = e.target.value;
            updateClock();
            autoSaveSettings();
        });

        // Date format dropdown - auto-save
        document.getElementById('date-format').addEventListener('change', e => {
            settings.date_format = e.target.value;
            // Reinitialize date pickers with new week start day
            initDatePickers();
            // Reinitialize time pickers (12/24 hour format may change)
            initTimePickers();
            // Reload weekly overview to reflect new week start day
            loadWeeklyOverview();
            if (document.getElementById('history-view').classList.contains('active')) {
                loadHistory();
            }
            autoSaveSettings();
        });

        document.getElementById('clock-format').addEventListener('change', e => {
            settings.clock_format = e.target.value;
            updateClock(); // Immediately update clock display
            initTimePickers(); // Reinitialize time pickers with new format
            autoSaveSettings();
        });

        document.getElementById('period-labels').addEventListener('change', e => {
            settings.period_labels = e.target.value;
            loadWeeklyOverview(); // Reload to show new labels
            autoSaveSettings();
        });

        document.getElementById('daily-minutes-goal').addEventListener('change', e => {
            settings.daily_minutes_goal = parseInt(e.target.value) || 300;
            loadReport(); // Reload to show updated goal line
            autoSaveSettings();
        });

        // Utility
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Type management functions
        function populateTypeDropdowns() {
            const types = settings.pomodoro_types || [];
            // Ensure all types are strings
            const stringTypes = types.map(t => String(t)).filter(t => t && t.trim());
            const selects = ['pomo-type', 'add-type', 'timer-pomo-type', 'edit-type'];
            selects.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                const currentValue = select.value;
                select.innerHTML = stringTypes.map(t => `<option value="${escapeHtml(t)}">${escapeHtml(t)}</option>`).join('');
                if (currentValue && stringTypes.includes(currentValue)) {
                    select.value = currentValue;
                }
            });
        }

        function renderTypesList() {
            const types = settings.pomodoro_types || [];
            const container = document.getElementById('types-list');
            container.innerHTML = types.map((t, i) => `
                <div class="type-item" draggable="true" data-index="${i}">
                    <div style="display: flex; align-items: center;">
                        <span class="drag-handle">☰</span>
                        <span>${escapeHtml(t)}</span>
                    </div>
                    <button onclick="removeType(${i})" title="Remove">&#10005;</button>
                </div>
            `).join('');

            // Add drag and drop event listeners
            const items = container.querySelectorAll('.type-item');
            items.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
            });
        }

        let draggedIndex = null;

        function handleDragStart(e) {
            const typeItem = e.target.closest('.type-item');
            if (!typeItem) return;
            draggedIndex = parseInt(typeItem.dataset.index);
            typeItem.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            const typeItem = e.target.closest('.type-item');
            if (typeItem) {
                typeItem.classList.remove('dragging');
            }
            document.querySelectorAll('.type-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const item = e.target.closest('.type-item');
            if (item && parseInt(item.dataset.index) !== draggedIndex) {
                item.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.target.closest('.type-item')?.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetItem = e.target.closest('.type-item');
            if (!targetItem) return;

            const targetIndex = parseInt(targetItem.dataset.index);
            if (targetIndex === draggedIndex) return;

            // Reorder the types array
            const types = settings.pomodoro_types || [];
            const [movedType] = types.splice(draggedIndex, 1);
            types.splice(targetIndex, 0, movedType);
            settings.pomodoro_types = types;

            renderTypesList();
            populateTypeDropdowns();
            autoSaveSettings();
        }

        function sortTypesAlphabetically() {
            if (!settings.pomodoro_types) return;
            settings.pomodoro_types.sort((a, b) => a.localeCompare(b));
            renderTypesList();
            populateTypeDropdowns();
            autoSaveSettings();
        }

        async function autoSaveSettings() {
            await fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });
        }

        function addNewType() {
            const input = document.getElementById('new-type-input');
            const newType = input.value.trim();
            if (!newType) return;
            if (!settings.pomodoro_types) settings.pomodoro_types = [];
            if (settings.pomodoro_types.includes(newType)) {
                alert('This type already exists');
                return;
            }
            settings.pomodoro_types.push(newType);
            input.value = '';
            renderTypesList();
            populateTypeDropdowns();
            autoSaveSettings();
        }

        function removeType(index) {
            if (!settings.pomodoro_types || settings.pomodoro_types.length <= 1) {
                alert('You must have at least one type');
                return;
            }
            settings.pomodoro_types.splice(index, 1);
            renderTypesList();
            populateTypeDropdowns();
            autoSaveSettings();
        }

        // Google Auth functions
        let authStatus = { logged_in: false };

        async function checkAuthStatus() {
            const res = await fetch('/api/auth/status');
            authStatus = await res.json();
            updateAuthUI();

            if (authStatus.logged_in) {
                // If needs initial sync, show sync options modal (for shared cache migration, etc.)
                if (authStatus.needs_initial_sync) {
                    await showInitialSyncModal();
                }
                // Always refresh from Google Sheets after any modal handling
                try {
                    await fetch('/api/sync/now', { method: 'POST' });
                } catch (e) {
                    console.error('Failed to sync from Google Sheets:', e);
                }
            }

            // Always load settings (works with SQLite locally or Google Sheets when logged in)
            await loadSettings();
        }

        async function showInitialSyncModal() {
            // Check data counts from both sources BEFORE syncing anything
            try {
                const res = await fetch('/api/sync/check');
                const data = await res.json();

                const modal = document.getElementById('initial-sync-modal');
                const titleEl = document.getElementById('sync-modal-title');
                const descEl = document.getElementById('sync-modal-desc');
                const countsEl = document.getElementById('sync-counts');
                const actionsEl = document.getElementById('sync-modal-actions');

                const localCount = data.local_count || 0;
                const sharedCacheCount = data.shared_cache_count || 0;
                const sheetsCount = data.sheets_count || 0;

                // Clear previous content
                actionsEl.innerHTML = '';

                // Priority: shared cache (data from before login) > local > sheets
                if (sharedCacheCount > 0) {
                    // Found data in shared cache from before login
                    titleEl.textContent = 'Upload Your Local Work?';
                    descEl.textContent = 'You have pomodoros from before you logged in. Would you like to upload them to Google Sheets?';
                    let countsHtml = `<span style="color: var(--accent);">Found ${sharedCacheCount} pomodoro${sharedCacheCount > 1 ? 's' : ''} from local session.</span>`;
                    if (sheetsCount > 0) {
                        countsHtml += `<br><span style="color: var(--success);">Also found ${sheetsCount} pomodoro${sheetsCount > 1 ? 's' : ''} in Google Sheets.</span>`;
                    }
                    countsEl.innerHTML = countsHtml;
                    actionsEl.innerHTML = `
                        <button class="secondary" onclick="performInitialSync('skip', 'skip')">No, Discard Local</button>
                        <button class="primary" onclick="performInitialSync('shared_cache_to_sheets', 'skip')">Yes, Upload to Sheets</button>
                    `;
                } else if (localCount === 0 && sheetsCount === 0) {
                    // Neither has data - just complete sync silently
                    await performInitialSync('skip', 'skip');
                    return;
                } else if (localCount > 0 && sheetsCount === 0) {
                    // Only local has data - offer to push to sheets
                    titleEl.textContent = 'Upload Local Data?';
                    descEl.textContent = 'You have pomodoros on this device. Would you like to upload them to Google Sheets?';
                    countsEl.innerHTML = `<span style="color: var(--accent);">Found ${localCount} pomodoro${localCount > 1 ? 's' : ''} locally.</span>`;
                    actionsEl.innerHTML = `
                        <button class="secondary" onclick="performInitialSync('skip', 'skip')">No, Start Fresh</button>
                        <button class="primary" onclick="performInitialSync('local_to_sheets', 'local_to_sheets')">Yes, Upload</button>
                    `;
                } else if (localCount === 0 && sheetsCount > 0) {
                    // Only sheets has data - auto-download silently
                    await performInitialSync('sheets_to_local', 'sheets_to_local');
                    return;
                } else {
                    // Both have data - ask user to choose
                    titleEl.textContent = 'Data Found in Both Places';
                    descEl.textContent = 'You have data on this device AND in Google Sheets. What would you like to do?';
                    countsEl.innerHTML = `
                        <span style="color: var(--accent);">${localCount} pomodoro${localCount > 1 ? 's' : ''} locally</span><br>
                        <span style="color: var(--success);">${sheetsCount} pomodoro${sheetsCount > 1 ? 's' : ''} in Google Sheets</span>
                    `;
                    actionsEl.innerHTML = `
                        <button class="secondary" onclick="performInitialSync('sheets_to_local', 'sheets_to_local')">Use Google Sheets</button>
                        <button class="primary" onclick="performInitialSync('local_to_sheets', 'local_to_sheets')">Upload Local Data</button>
                    `;
                }

                modal.classList.add('active');
            } catch (e) {
                console.error('Failed to check sync sources:', e);
            }
        }

        async function performInitialSync(pomodorosDirection, settingsDirection) {
            const modal = document.getElementById('initial-sync-modal');
            const descEl = document.getElementById('sync-modal-desc');
            const actionsEl = document.getElementById('sync-modal-actions');

            descEl.textContent = 'Syncing...';
            actionsEl.innerHTML = '';

            try {
                const res = await fetch('/api/migrate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pomodoros_direction: pomodorosDirection,
                        settings_direction: settingsDirection
                    })
                });
                const data = await res.json();

                if (data.success) {
                    modal.classList.remove('active');
                    // Reload all data views
                    await loadWeeklyOverview();  // Refresh Timer tab
                    await loadHistory();
                    await loadSettings();

                    // Show status message
                    const statusEl = document.getElementById('migrate-status');
                    if (statusEl) {
                        statusEl.style.display = 'block';
                        statusEl.style.color = 'var(--success)';
                        if (data.pomodoros_migrated > 0) {
                            statusEl.textContent = `✓ Synced ${data.pomodoros_migrated} pomodoros`;
                        } else {
                            statusEl.textContent = '✓ Sync complete';
                        }
                    }
                } else {
                    descEl.textContent = 'Sync failed: ' + (data.error || 'Unknown error');
                    descEl.style.color = 'var(--accent)';
                    actionsEl.innerHTML = `<button class="primary" onclick="document.getElementById('initial-sync-modal').classList.remove('active')">Close</button>`;
                }
            } catch (e) {
                descEl.textContent = 'Sync failed: ' + e.message;
                descEl.style.color = 'var(--accent)';
                actionsEl.innerHTML = `<button class="primary" onclick="document.getElementById('initial-sync-modal').classList.remove('active')">Close</button>`;
            }
        }

        function updateAuthUI() {
            const loggedOut = document.getElementById('google-logged-out');
            const loggedIn = document.getElementById('google-logged-in');
            const loginBtn = document.getElementById('google-login-btn');
            const notConfigured = document.getElementById('google-not-configured');

            if (authStatus.logged_in) {
                loggedOut.style.display = 'none';
                loggedIn.style.display = 'block';
                document.getElementById('google-name').textContent = authStatus.name || '';
                document.getElementById('google-email').textContent = authStatus.email || '';
                document.getElementById('spreadsheet-id').value = authStatus.spreadsheet_id || '';
                if (authStatus.picture) {
                    document.getElementById('google-avatar').src = authStatus.picture;
                }
            } else {
                loggedOut.style.display = 'block';
                loggedIn.style.display = 'none';
                if (!authStatus.google_configured) {
                    loginBtn.disabled = true;
                    loginBtn.style.opacity = '0.5';
                    notConfigured.style.display = 'block';
                }
            }
        }

        async function updateSpreadsheetId() {
            const newId = document.getElementById('spreadsheet-id').value.trim();
            const statusEl = document.getElementById('spreadsheet-id-status');

            if (!newId) {
                statusEl.style.display = 'block';
                statusEl.style.color = 'var(--accent)';
                statusEl.textContent = 'Please enter a spreadsheet ID';
                return;
            }

            statusEl.style.display = 'block';
            statusEl.style.color = 'var(--text-secondary)';
            statusEl.textContent = 'Updating...';

            try {
                const res = await fetch('/api/auth/spreadsheet', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ spreadsheet_id: newId })
                });
                const data = await res.json();

                if (data.error) {
                    statusEl.style.color = 'var(--accent)';
                    statusEl.textContent = 'Error: ' + data.error;
                } else {
                    statusEl.style.color = 'var(--success)';
                    statusEl.textContent = '✓ Spreadsheet ID updated';
                    authStatus.spreadsheet_id = newId;
                    // Refresh data from new spreadsheet
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 3000);
                }
            } catch (e) {
                statusEl.style.color = 'var(--accent)';
                statusEl.textContent = 'Error: ' + e.message;
            }
        }

        async function refreshFromSheets() {
            const statusEl = document.getElementById('migrate-status');
            statusEl.style.display = 'block';
            statusEl.style.color = 'var(--text-secondary)';
            statusEl.textContent = 'Refreshing data from Google Sheets...';

            try {
                const res = await fetch('/api/sync/now', { method: 'POST' });
                const data = await res.json();

                if (data.error) {
                    statusEl.style.color = 'var(--accent)';
                    statusEl.textContent = 'Refresh failed: ' + data.error;
                } else {
                    statusEl.style.color = 'var(--success)';
                    statusEl.textContent = `✓ Refreshed ${data.synced_from_sheets} pomodoros from Google Sheets`;

                    // Reload all data views
                    loadWeeklyOverview();
                    loadHistory();
                    loadSettings();
                }
            } catch (e) {
                statusEl.style.color = 'var(--accent)';
                statusEl.textContent = 'Refresh failed: ' + e.message;
            }
        }

        function migrateData() {
            document.getElementById('migrate-modal').classList.add('active');
        }

        function hideMigrateModal() {
            document.getElementById('migrate-modal').classList.remove('active');
        }

        async function runMigration() {
            const settingsDirection = document.querySelector('input[name="settings-direction"]:checked').value;
            hideMigrateModal();

            const statusEl = document.getElementById('migrate-status');
            statusEl.style.display = 'block';
            statusEl.style.color = 'var(--text-secondary)';
            statusEl.textContent = 'Migrating...';

            try {
                const res = await fetch('/api/migrate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        pomodoros_direction: 'local_to_sheets',
                        settings_direction: settingsDirection
                    })
                });
                const data = await res.json();
                if (data.success) {
                    statusEl.style.color = 'var(--success)';
                    let msg = `✓ Migrated ${data.pomodoros_migrated} pomodoros`;
                    if (data.pomodoros_skipped > 0) {
                        msg += ` (${data.pomodoros_skipped} already existed)`;
                    }
                    if (data.settings_direction !== 'skip') {
                        msg += `, ${data.settings_migrated} settings`;
                    }
                    statusEl.textContent = msg;
                    // Reload settings if we pulled from sheets
                    if (settingsDirection === 'sheets_to_local') {
                        loadSettings();
                    }
                } else {
                    statusEl.style.color = 'var(--accent)';
                    statusEl.textContent = 'Migration failed: ' + (data.error || 'Unknown error');
                }
            } catch (e) {
                statusEl.style.color = 'var(--accent)';
                statusEl.textContent = 'Migration failed: ' + e.message;
            }
        }

        // Request notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }

        // Init
        populateTimezoneDropdown();
        startClock();
        (async () => {
            await checkAuthStatus();
            await loadWeeklyOverview();
            await loadHistory();
        })();
    </script>
</body>
</html>
